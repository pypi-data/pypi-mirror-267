"use strict";(self.webpackChunkloops_diff=self.webpackChunkloops_diff||[]).push([[6956],{66956:(e,t,s)=>{s.r(t),s.d(t,{default:()=>g});const n=/^<[^>]+>/,o=/^<img[^>]*>$/,i=/^<video[^>]*>.*?<\/video>$/ms,d="html-diff-create-text-wrapper",r="html-diff-delete-text-wrapper",l="html-diff-create-block-wrapper",a="html-diff-delete-block-wrapper",c="html-diff-create-inline-wrapper",h="html-diff-delete-inline-wrapper",p='<span class="html-diff-close-icon"></span>';function w(e,t){const s=t.length;if(!s)return"";let d="",r=0;for(let l=0;l<s;l++){const s=t[l];s.match(n)&&(l>r&&(d+=f(e,t.slice(r,l))),r=l+1,s.match(i)?d+=S(e,s):[o].some((e=>s.match(e)))?d+=u(e,s):d+=s)}return r<s&&(d+=f(e,t.slice(r))),d}function f(e,t){const s=t.join("");return s.trim()?"create"===e?`<span class="${d}">${s}</span>`:"delete"===e?`<span class="${r}">${s}</span>`:"":""}function u(e,t){return"create"===e?`<span class="${c}">${t}</span>`:"delete"===e?`<span class="${h}">${t}${p}</span>`:""}function S(e,t){return"create"===e?`<div class="${l}">${t}</div>`:"delete"===e?`<div class="${a}">${t}${p}</div>`:""}const m=/^<(?<name>[^\s/>]+)[^>]*>$/,E=/^<(?<isEnd>\/)?(?<name>[^\s>]+)[^>]*>$/;class g{minMatchedSize;oldWords=[];newWords=[];matchedBlockList=[];operationList=[];unifiedContent;sideBySideContents;constructor(e,t,s=2){if(this.minMatchedSize=s,e===t)return this.unifiedContent=e,void(this.sideBySideContents=[e,t]);this.oldWords=this.convertHtml2Words(e),this.newWords=this.convertHtml2Words(t),this.matchedBlockList=this.getMatchedBlockList(),this.operationList=this.getOperationList()}convertHtml2Words(e){return e.match(/<video[^>]*>.*?<\/video>|<[^>]+>|\w+\b|\s+|[^<>\w]/gms)||[]}getMatchedBlockList(e=0,t=this.oldWords.length,s=0,n=this.newWords.length,o=[]){const i=this.getBestMatchedBlock(e,t,s,n);return i?(e<i.oldStart&&s<i.newStart&&this.getMatchedBlockList(e,i.oldStart,s,i.newStart,o),o.push(i),t>i.oldEnd&&n>i.newEnd&&this.getMatchedBlockList(i.oldEnd,t,i.newEnd,n,o),o):[]}getBestMatchedBlock(e,t,s,n){let o=null;for(let i=e;i<t;i++){const e=this.slideBestMatchedBlock(i,s,Math.min(t-i,n-s));e&&e.size>(o?.size||0)&&(o=e)}for(let i=s;i<n;i++){const s=this.slideBestMatchedBlock(e,i,Math.min(t-e,n-i));s&&s.size>(o?.size||0)&&(o=s)}return o}slideBestMatchedBlock(e,t,s){let n=0,o=null,i=0;for(let d=0;d<s;d++)this.oldWords[e+d]===this.newWords[t+d]?i++:i=0,i>n&&(n=i,o={oldStart:e+d-i+1,oldEnd:e+d+1,newStart:t+d-i+1,newEnd:t+d+1,size:i});return n>=this.minMatchedSize?o:null}getOperationList(){const e=[];let t=0,s=0;for(const n of this.matchedBlockList){const o=t===n.oldStart,i=s===n.newStart,d={oldStart:t,oldEnd:n.oldStart,newStart:s,newEnd:n.newStart};o||i?o&&!i?e.push(Object.assign(d,{type:"create"})):!o&&i&&e.push(Object.assign(d,{type:"delete"})):e.push(Object.assign(d,{type:"replace"})),e.push({oldStart:n.oldStart,oldEnd:n.oldEnd,newStart:n.newStart,newEnd:n.newEnd,type:"equal"}),t=n.oldEnd,s=n.newEnd}const n=this.oldWords.length,o=this.newWords.length,i={oldStart:t,oldEnd:n,newStart:s,newEnd:o},d=t===n,r=s===o;return d||r?d&&!r?e.push(Object.assign(i,{type:"create"})):!d&&r&&e.push(Object.assign(i,{type:"delete"})):e.push(Object.assign(i,{type:"replace"})),e}getUnifiedContent(){if(void 0!==this.unifiedContent)return this.unifiedContent;let e="";return this.operationList.forEach((t=>{switch(t.type){case"equal":for(const s of this.newWords.slice(t.newStart,t.newEnd))e+=s;break;case"delete":e+=w("delete",this.oldWords.slice(t.oldStart,t.oldEnd));break;case"create":e+=w("create",this.newWords.slice(t.newStart,t.newEnd));break;case"replace":const s=this.oldWords.slice(t.oldStart,t.oldEnd),d=this.newWords.slice(t.newStart,t.newEnd);if(1===s.length&&1===d.length&&s[0].match(n)&&d[0].match(n)){e+=d[0];break}const r=[],l=[];let a=t.newStart;for(let s=t.oldStart;s<t.oldEnd;s++){const n=this.oldWords[s],d=n.match(E);if(d){if([o,i].some((e=>n.match(e)))){r.push(n);continue}e+=w("delete",r),r.splice(0);let s=!1;for(let n=a;n<t.newEnd;n++){const t=this.newWords[n],o=t.match(E);if(o&&o.groups.name===d.groups.name&&o.groups.isEnd===d.groups.isEnd){s=!0,e+=w("create",l),e+=t,l.splice(0),a=n+1;break}l.push(t)}s||(e+=n,l.splice(0))}else r.push(n)}a<t.newEnd&&l.push(...this.newWords.slice(a,t.newEnd)),e+=w("delete",r),e+=w("create",l);break;default:const c=t.type;console.error("Error operation type: "+c)}})),this.unifiedContent=e,e}getSideBySideContents(){if(void 0!==this.sideBySideContents)return this.sideBySideContents;let e="",t="",s=0;this.operationList.forEach((n=>{switch(n.type){case"equal":const o=this.newWords.slice(n.newStart,n.newEnd);let i="";for(const e of o){const t=e.match(m);if(t){s+=1;const n=t.groups.name.length+1;i+=`${e.slice(0,n)} data-seq="${s}"${e.slice(n)}`}else i+=e}e+=i,t+=i;break;case"delete":const d=this.oldWords.slice(n.oldStart,n.oldEnd);e+=w("delete",d);break;case"create":const r=this.newWords.slice(n.newStart,n.newEnd);t+=w("create",r);break;case"replace":const l=this.oldWords.slice(n.oldStart,n.oldEnd);e+=w("delete",l);const a=this.newWords.slice(n.newStart,n.newEnd);t+=w("create",a);break;default:const c=n.type;console.error("Error operation type: "+c)}}));const n=[e,t];return this.sideBySideContents=n,n}}}}]);