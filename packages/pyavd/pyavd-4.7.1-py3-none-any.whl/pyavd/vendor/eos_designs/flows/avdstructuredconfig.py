# Copyright (c) 2023-2024 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.
from __future__ import annotations

from functools import cached_property

from pyavd.vendor.j2.filter.natural_sort import natural_sort
from pyavd.vendor.avdfacts import AvdFacts
from pyavd.vendor.errors import AristaAvdMissingVariableError
from pyavd.vendor.strip_empties import strip_null_from_data
from pyavd.vendor.utils import get, get_item


class AvdStructuredConfigFlows(AvdFacts):
    """
    This class must be rendered after all other eos_designs modules since it relies on
    detecting sflow from the interface structured config generated by the other modules.

    The only exception is of course custom_structured_configuration which always comes last.
    """

    @cached_property
    def sflow(self) -> dict | None:
        """
        Structured config for sFlow.

        Only configure if any interface is enabled for sFlow.

        Covers:
        - sflow_settings
        - source-interfaces based on source_interfaces.sflow
        """
        if not self._enable_sflow:
            return None

        destinations = get(self._hostvars, "sflow_settings.destinations")
        if destinations is None:
            # TODO:
            # AVD5.0.0 raise an error if sflow is enabled on an interface but there are no destinations configured.
            # This cannot be implemented today since it would be breaking for already released support for sflow on interfaces.
            return None

        sflow_settings_vrfs = get(self._hostvars, "sflow_settings.vrfs", default=[])

        # At this point we have at least one interface with sFlow enabled
        # and at least one destination.
        sflow = {"run": True}

        # Using a temporary dict for VRFs
        sflow_vrfs = {}

        for destination in natural_sort(destinations, "destination"):
            vrf = get(destination, "vrf")
            if vrf is None:
                vrf = self.shared_utils.default_mgmt_protocol_vrf
                source_interface = self.shared_utils.default_mgmt_protocol_interface

            elif vrf == "use_mgmt_interface_vrf":
                if (self.shared_utils.mgmt_ip is None) and (self.shared_utils.ipv6_mgmt_ip is None):
                    raise AristaAvdMissingVariableError(
                        "Unable to configure sFlow source-interface with 'use_mgmt_interface_vrf' since 'mgmt_ip' or 'ipv6_mgmt_ip' are not set."
                    )

                vrf = self.shared_utils.mgmt_interface_vrf
                source_interface = get(get_item(sflow_settings_vrfs, "name", vrf, default={}), "source_interface", default=self.shared_utils.mgmt_interface)

            elif vrf == "use_inband_mgmt_vrf":
                # Check for missing interface
                if self.shared_utils.inband_mgmt_interface is None:
                    raise AristaAvdMissingVariableError(
                        "Unable to configure sFlow source-interface with 'use_inband_mgmt_vrf' since 'inband_mgmt_interface' is not set."
                    )

                # self.shared_utils.inband_mgmt_vrf returns None for the default VRF, but here we need "default" to avoid duplicates.
                vrf = self.shared_utils.inband_mgmt_vrf or "default"
                source_interface = get(
                    get_item(sflow_settings_vrfs, "name", vrf, default={}), "source_interface", default=self.shared_utils.inband_mgmt_interface
                )

            else:
                # Default is none, meaning we will not configure a source interface for this VRF.
                source_interface = get(get_item(sflow_settings_vrfs, "name", vrf, default={}), "source_interface")

            if vrf in [None, "default"]:
                # Add destination without VRF field
                sflow.setdefault("destinations", []).append(
                    {
                        "destination": destination.get("destination"),
                        "port": destination.get("port"),
                    }
                )
                sflow["source_interface"] = source_interface

            else:
                # Add destination with VRF field.
                sflow_vrfs.setdefault(vrf, {}).setdefault("destinations", []).append(
                    {
                        "destination": destination.get("destination"),
                        "port": destination.get("port"),
                    }
                )
                sflow_vrfs[vrf]["source_interface"] = source_interface

        # convert sflow_vrfs dict into list and insert into sflow
        if sflow_vrfs:
            sflow["vrfs"] = [{"name": vrf_name, **vrf} for vrf_name, vrf in sflow_vrfs.items()]

        return strip_null_from_data(sflow)

    @cached_property
    def _enable_sflow(self) -> bool:
        """
        Enable sFlow if any interface is enabled for sFlow.

        This relies on sFlow being rendered after all other eos_designs modules (except structured config).
        """
        for interface in get(self._hostvars, "ethernet_interfaces", default=[]):
            if get(interface, "sflow.enable") is True:
                return True

        for interface in get(self._hostvars, "port_channel_interfaces", default=[]):
            if get(interface, "sflow.enable") is True:
                return True

        return False
