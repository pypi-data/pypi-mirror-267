# candycan


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

Features:

- Support both native SocketCAN and Python-CAN (SocketCAN, Kvaser,
  Vector, etc.)
- Production level data encapsulation with cached properties
- Message parsing with DBC file
- Automatic data validation via Pydantic
- Virtual CAN testing inside Jupyter notebook with multiprocessing
  support
- Highly efficient a2l file handling with lazy loading and dynamic
  properties
- Fast file loading by streaming json processing

Itâ€™s based on Python-CAN, Scapy, cantools and dbc-editor

## Install

Install all the dependencies listed in can-env.yaml and then install
candycan

``` sh
pip install candycan
```

## [Data link layer (ISO 11898-1)](https://en.wikipedia.org/wiki/CAN_bus)

- Frame sending and receiving
- conversion from Python dict object to json and CAN frame
- message parsing with given dbc
- Multiprocessing support for testing inside the notebook
- Secure CAN device add/remove with password proctected gpg encryption
- Flexible arguments setting with argparse and subprocess pipes
- on native
  [SocketCan](https://www.kernel.org/doc/html/next/networking/can.html)
  or [Python-CAN](https://python-can.readthedocs.io/en/stable/) virtual
  CAN channel
- Options with Python-CAN or
  [Scapy](https://scapy.readthedocs.io/en/latest/introduction.html)
  backends
- integrate [can-utils](https://github.com/linux-can/can-utils), scapy
  [sniff](https://scapy.readthedocs.io/en/latest/usage.html) for large
  scale testing (tbd)
- extend to Kvaser, Vector, etc. (tbd)

## [CCP](https://en.wikipedia.org/wiki/XCP_(protocol))

- on physical CAN device (Kvaser) with Scapy application interface
- on physical CAN device with Python-CAN and CCP logic
- context manager for CCP functions
- CCP/XCP data codecs and data processing in Numpy array
- Bytes codecs (raw binary, hex, numeric) with endianess handling
- Flexible arguments setting with argparse and interactive InquirerPy
- Encapsulation of CAN specs in unified
  [Pydantic](https://docs.pydantic.dev/latest/) models (serialization,
  schema, validation, annotation, etc.)
- Self incremental command counter inside CAN specs object
- Type systems for CAN (native SocketCAN, Python-CAN) and bus
  (SocketCAN, virtual CAN, Kvaser, Vector, etc.)

## A2L

- a2l checking and fixing with
  [pya2l](https://github.com/christoph2/pyA2L.git) and
  [a2ltool](https://github.com/DanielT/a2ltool)
- conversion a2l file to legit json files
- al2 tree node, path and path segment definitions for positioning
  semantics
- searching of calibration terms
- Calibration object with dynamic properties for easy access of class
  attributes
- Cached properties for automatic data conversion and derivative
  properties like data size for corresponding data type
- Exception handling with missing calibration properties
- Unified processing of measurement, axis, conversion method and data
  layouts
- Lazy loading and streaming json file processing with events based
  [ijson](https://github.com/ICRAR/ijson)
- Encapsulation of calibration properties and values in Pydantic objects
  (automatic validation, serialization, schemes, etc.)
- Type systems for CCP/XCP data types
- XCPConfig for CCP/XCP configuration
- XCPData for encapsulating calibration data with automatic dimension,
  data size validation, automatic codecs of hex, raw and numeric values
- array view of table data as cached property with automatic type
  conversion and validation
- Create calibration data object from a2l file
- Get calibration data from downloaded json file

## DBC

- load dbc files with [cantools](https://github.com/cantools/cantools)
- append new messages and signals to dbc files
- GUI for interactively modifying dbc on the command line with
  [dbc-editor](https://gitlab.com/erzo/dbc-editor)

## XCP (tbd)
