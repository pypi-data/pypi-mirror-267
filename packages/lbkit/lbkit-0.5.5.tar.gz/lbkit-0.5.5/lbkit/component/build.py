"""组件构建"""
import os
import yaml
import shutil
import re
import json
from argparse import ArgumentParser
from git import Repo
from git.exc import InvalidGitRepositoryError
from mako.lookup import TemplateLookup
from lbkit.misc import Color, validate_yml_with_json_schema
from lbkit import errors
from lbkit.codegen.codegen import CodeGen
from lbkit.tools import Tools

tools = Tools("comp_build")
log = tools.log
cwd = os.getcwd()
lb_cwd = os.path.split(os.path.realpath(__file__))[0]


class DeployComponent():
    def __init__(self, package_ref, package_id, rootfs_dir):
        self.package_ref = package_ref
        self.package_id = package_id
        self.rootfs_dir = rootfs_dir

    def run(self):
        if self.package_ref.startswith("deploy"):
            return
        cmd = f"conan cache path {self.package_ref}:{self.package_id}"
        package_folder = tools.run(cmd).stdout.strip()
        log.info(f">>copy {package_folder} to {self.rootfs_dir}")
        cmd = f"cp -rT {package_folder}/ {self.rootfs_dir}"
        tools.exec(cmd)


class BuildComponent():
    def __init__(self, args_parser: ArgumentParser, args=None):
        self.options = args_parser.parse_args(args)
        self.options.build_type = self.options.build_type.capitalize()
        if self.options.channel is None or self.options.channel.strip() == "":
            raise errors.ArgException("请正确指定-c, --channel指定conan包的channel通道")
        self.channel = self.options.channel
        self.build_type = self.options.build_type
        self.profile = self.options.profile
        self.profile_build = self.options.profile_build
        self.runtime_packages = []
        self.verbose = False if self.options.summary else True
        self.from_source = self.options.from_source
        # 当前组件及其依赖将被部署到rootfs目录
        self.rootfs_dir = os.path.join(cwd, ".temp", "rootfs")
        shutil.rmtree(self.rootfs_dir, ignore_errors=True)
        os.makedirs(self.rootfs_dir, exist_ok=True)

        self.pkg = None
        self.gen_conaninfo()
        self.base_cmd = f" --user {self.user} --channel {self.channel}"
        self.base_cmd += f" -pr {self.profile} -s build_type={self.build_type} -r " + self.options.remote
        self.base_cmd += f" -pr:b {self.profile_build}"
        if self.options.cov:
            self.base_cmd += f" -o {self.name}/*:gcov=True"
        if self.options.test:
            self.base_cmd += f" -o {self.name}/*:test=True"
        for pkg_option in self.options.pkg_options:
            self.base_cmd += " -o " + pkg_option

    def get_package_version(self):
        """
        从CMakeLists.txt读取版本号，格式需要满足正则表达式：project\((.*)VERSION ([0-9][1-9]*.[0-9][1-9]*.[0-9][1-9]*)\)
        示例: project(gcom LANGUAGES C VERSION 0.1.0)
        """
        try:
            fp = open("CMakeLists.txt", "r")
            content = fp.read()
            version = re.search("project\((.*)VERSION ([0-9][1-9]*.[0-9][1-9]*.[0-9][1-9]*)\)", content).group(2)
            return version.strip()
        except Exception as e:
            print(str(e))
            return None

    @property
    def _is_conanfile_tracked(self):
        """检查conanfile.py是否被git跟踪"""
        try:
            repo = Repo(".")
            for entry in repo.commit().tree.traverse():
                if entry.path == "conanfile.py":
                    return True
        except InvalidGitRepositoryError as e:
            log.error("Invalid git repository, conanfile.py will be generated by lbkit")
        return False

    def gen_conaninfo(self):
        package_yml = os.path.join(cwd, "metadata/package.yml")
        if not os.path.isfile(package_yml):
            raise FileNotFoundError("metadata/package.yml文件不存在")
        # 验证失败时抛异常，此处不用处理，由外层处理
        validate_yml_with_json_schema(package_yml, "/usr/share/litebmc/schema/cdf.v1.json")
        log.info(f"validate {package_yml} successfully")

        # 加载package.yml文件
        fp = open(package_yml, "r")
        pkg = yaml.safe_load(fp)
        fp.close()
        self.user = pkg.get("user")
        if self.user is None:
            raise errors.PackageConfigException("metadata/package.yml未正确配置user字段")
        # 构建命令未指定channel时从package.yml中读取
        pkg["channel"] = self.channel
        pkg["version"] = self.get_package_version()
        self.pkg = pkg
        # 从package.yml加载基础信息
        self.name = pkg.get("name")
        self.version = pkg.get("version")

        self.package = self.name + "/" + self.version + \
            "@" + self.user + "/" + self.channel
        # 准备部署依赖
        requires = pkg.get("requires")
        if requires is not None:
            for rt in requires.get("test", []):
                conan = rt.get("conan")
                if conan is not None:
                    self.runtime_packages.append(conan)
            for rt in requires.get("compile", []):
                conan = rt.get("conan")
                if conan is not None:
                    self.runtime_packages.append(conan)

        # 生成conan构建脚本
        conanfile = os.path.join(cwd, "conanbase.py")
        # 当git未跟踪conanfile.py时生成新的conanfile.py
        if not self._is_conanfile_tracked:
            conanfile = os.path.join(cwd, "conanfile.py")

        # 使用litebmc.conanfile.mako模板生成基础litebmc公共conanfile
        lookup = TemplateLookup(directories=os.path.join(lb_cwd, "template"))
        template = lookup.get_template("conanbase.mako")
        conandata = template.render(lookup=lookup, pkg=pkg, conanfile_tracked=self._is_conanfile_tracked)
        # 写入文件
        fp = open(conanfile, "w")
        fp.write(conandata)
        fp.close()

    def upload(self):
        log.success(f"start upload {self.package}")
        cmd = "conan upload {}# -r {}".format(
            self.package, self.options.remote)
        if self.options.upload_recipe:
            cmd += " --only-recipe"
        tools.exec(cmd, verbose=True)

    def _build_dependencies(self):
        log.success(f"start build dependeicies package of {self.package}")
        if self.from_source:
            return
        # 生成部署deploy命令
        lookup = TemplateLookup(directories=os.path.join(lb_cwd, "template"))
        template = lookup.get_template("deploy.mako")
        deploy = template.render(lookup=lookup, pkg=self.pkg, packages=self.runtime_packages)
        dir = os.path.join(cwd, ".temp", "deploy")
        # 创建临时目录并写入conanfile.py文件
        os.makedirs(dir, exist_ok=True)
        conanfile = os.path.join(dir, "conanfile.py")
        fp = open(conanfile, "w")
        fp.write(deploy)
        fp.close()
        os.chdir(dir)

        cmd = self.base_cmd.replace(self.package, "")
        cmd = f"conan create . {cmd} --build=missing -tf=\"\""
        tools.exec(cmd, verbose=True)
        os.chdir(cwd)

    def deploy(self):
        log.success(f"start deplay {self.package} and it's dependencies to ./temp/rootfs")
        # 生成部署deploy命令
        lookup = TemplateLookup(directories=os.path.join(lb_cwd, "template"))
        template = lookup.get_template("deploy.mako")
        packages = self.runtime_packages
        packages.append(self.package)
        deploy = template.render(lookup=lookup, pkg=self.pkg, packages=packages)
        dir = os.path.join(cwd, ".temp", "deploy")
        # 创建临时目录并写入conanfile.py文件
        os.makedirs(dir, exist_ok=True)
        conanfile = os.path.join(dir, "conanfile.py")
        fp = open(conanfile, "w")
        fp.write(deploy)
        fp.close()
        os.chdir(dir)

        cmd = self.base_cmd.replace(self.package, "")
        cmd = f"conan graph info . {cmd} --build=missing -f json --filter=ref --filter=package_id"
        res = tools.run(cmd).stdout.strip()
        graph = json.loads(res)
        nodes = graph.get("graph", {}).get("nodes", {})
        for id, info in nodes.items():
            ref = info.get("ref")
            id = info.get("package_id")
            dep = DeployComponent(ref, id, self.rootfs_dir)
            dep.run()

        # 设置ROOTFS_DIR环境变量，为DT测试提供相对路径
        os.environ["ROOTFS_DIR"] = self.rootfs_dir

    def _validate_odf_files(self):
        odf_dirs = self.pkg.get("odf_dirs", [])
        for dir in odf_dirs:
            for filename in os.listdir(dir):
                filename = os.path.join(dir, filename)
                if not os.path.isfile(filename):
                    continue
                if not filename.endswith(".yaml"):
                    log.debug(f"file {filename} not endswith .yaml, skip validate")
                    continue

                log.info(f"start validate {filename}")
                validate_yml_with_json_schema(filename, "/usr/share/litebmc/schema/odf.v1.json")

    def run(self):
        # start validate all odf(Object Description file) files
        self._validate_odf_files()

        cmd = f"conan remove {self.package} -c"
        tools.exec(cmd)
        gen = CodeGen([])
        gen.run("./metadata/package.yml")
        self._build_dependencies()
        log.success(f"start build {self.package}")
        cmd = "conan create . {} -tf=\"\"".format(self.base_cmd)
        if self.from_source:
            cmd += " --build=\"*\""
        tools.exec(cmd, verbose=True)
        # 部署依赖
        self.deploy()
        if self.options.upload_recipe or self.options.upload_package:
            self.upload()
        log.success(f"build {self.package} successfully")

    @property
    def package_id(self):
        cmd = f"conan graph info . {self.base_cmd} --filter=package_id"
        res = tools.run(cmd)
        match = re.search(r"package_id: ([a-f0-9]{40})", res.stdout)
        if match is None:
            raise errors.LiteBmcException(f"Get package if of {self.package} failed")
        return match.group(1)

    @staticmethod
    def package_folder(self):
        cmd = f"conan cache path {self.package}#latest:{self.package_id}"
        res = tools.run(cmd)
        return res.stdout.strip()

    @property
    def build_folder(self):
        cmd = f"conan cache path {self.package}#latest:{self.package_id} --folder=build"
        res = tools.run(cmd)
        return res.stdout.strip()

    def test(self):
        try:
            self.run()
        except Exception as e:
            log.error(
                f"build {self.package} {Color.RED}failed{Color.RESET_ALL}")
            log.info(e)
            os._exit(-2)
