<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pycti.messages API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pycti.messages</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import struct
import logging
import re
from copy import deepcopy
from abc import ABC

logger = logging.getLogger(__name__)


class MessageABC(ABC):

    # The length of the message. Should be overwritten in child class
    msg_length = 0

    # The message command code. Should be overwritten in child class
    command_code = 0x00

    # Template that is specific to each message type. Should be overwritten in child class
    msg_specific_template = {}

    # Base message template that is common for all messages
    base_template = {
        &#39;header&#39;: {
            &#39;format&#39;: &#39;&lt;Q&#39;,
            &#39;start_byte&#39;: 0,
            &#39;value&#39;: 0x11DDDDDDDDDDDDDD
        },
        &#39;msg_length&#39;: {
            &#39;format&#39;: &#39;&lt;L&#39;,
            &#39;start_byte&#39;: 8,
            &#39;value&#39;: 0
        },
        &#39;command_code&#39;: {
            &#39;format&#39;: &#39;&lt;L&#39;,
            &#39;start_byte&#39;: 12,
            &#39;value&#39;: 0x00000000
        },
        &#39;extended_command_code&#39;: {
            &#39;format&#39;: &#39;&lt;L&#39;,
            &#39;start_byte&#39;: 16,
            &#39;value&#39;: 0x00000000
        },
    }

    @classmethod
    def unpack(cls, msg_bin: bytearray) -&gt; dict:
        &#34;&#34;&#34;
        Parses the passed message and decodes it with the msg_encoding dict.
        Each key in the output message will have name of the key from the 
        msg_encoding dictionary.

        Parameters
        ----------
        msg_bin : bytearry
            The message to unpack.

        Returns
        -------
        decoded_msg_dict : dict
            The message items decoded into a dictionary.
        &#34;&#34;&#34;
        decoded_msg_dict = {}

        # Create a template to unpack message with
        template = {**deepcopy(cls.base_template),
                   **deepcopy(cls.msg_specific_template)}

        for item_name, item in template.items():
            start_idx = item[&#39;start_byte&#39;]
            end_idx = item[&#39;start_byte&#39;] + struct.calcsize(item[&#39;format&#39;])
            decoded_msg_dict[item_name] = struct.unpack(
                item[&#39;format&#39;], msg_bin[start_idx:end_idx])[0]

            # Decode and strip trailing 0x00s from strings.
            if item[&#39;format&#39;].endswith(&#39;s&#39;):
                decoded_msg_dict[item_name] = decoded_msg_dict[item_name].decode(
                    item[&#39;text_encoding&#39;]).rstrip(&#39;\x00&#39;)

        if decoded_msg_dict[&#39;command_code&#39;] != cls.command_code:
            logger.warning(
                f&#39;Decoded command code {decoded_msg_dict[&#34;command_code&#34;]} does not match what was expected!&#39;)

        if decoded_msg_dict[&#39;msg_length&#39;] != cls.msg_length:
            logger.warning(
                f&#39;Decoded message length {decoded_msg_dict[&#34;msg_length&#34;]} does not match what was expected!&#39;)

        return decoded_msg_dict

    @classmethod
    def pack(cls, msg_values={}) -&gt; bytearray:
        &#34;&#34;&#34;
        Packs a message based on the message encoding given in the msg_specific_template
        dictionary. Values can be substituted for default values if they are included 
        in the `msg_values` argument.

        Parameters
        ----------
        msg_values : dict
            A dictionary detailing which default values in the message temple should be 
            updated.

        Returns
        -------
        msg_bin : bytearray
            Packed response message.
        &#34;&#34;&#34;
        # Create a template to build messages from
        template = {**deepcopy(cls.base_template),
                   **deepcopy(cls.msg_specific_template)}

        # Update the template with message specific length and command code
        template[&#39;msg_length&#39;][&#39;value&#39;] = cls.msg_length
        template[&#39;command_code&#39;][&#39;value&#39;] = cls.command_code

        # Create a message bytearray that will be loaded with message contents
        msg_bin = bytearray(template[&#39;msg_length&#39;][&#39;value&#39;])

        # Update default message values with those in the passed msg_values dict
        for key in msg_values.keys():
            if key in template.keys():
                template[key][&#39;value&#39;] = msg_values[key]
            else:
                logger.warning(
                    f&#39;Key name {key} was not found in msg_encoding!&#39;)

        # Pack each item in template. If packing any item fails then abort packing.
        for item_name, item in template.items():
            logger.debug(f&#39;Packing item {item_name}&#39;)
            try:
                if item[&#39;format&#39;].endswith(&#39;s&#39;) or item[&#39;format&#39;].endswith(&#39;c&#39;):
                    packed_item = struct.pack(
                        item[&#39;format&#39;],
                        item[&#39;value&#39;].encode(item[&#39;text_encoding&#39;]))
                else:
                    packed_item = struct.pack(
                        item[&#39;format&#39;], item[&#39;value&#39;])
            except struct.error as e:
                logger.error(
                    f&#39;Error packing {item_name} with fields {item}!&#39;)
                logger.error(e)
                msg_bin = bytearray([])
                break

            start_idx = item[&#39;start_byte&#39;]
            end_idx = item[&#39;start_byte&#39;] + struct.calcsize(item[&#39;format&#39;])
            msg_bin[start_idx:end_idx] = packed_item

        # Append a checksum to the end of the message
        if msg_bin:
            msg_bin += struct.pack(&#39;&lt;H&#39;, sum(msg_bin))

        return msg_bin


class Msg:
    class Login:
        &#39;&#39;&#39;
        Message for logging into Arbin cycler. See
        CTI_REQUEST_LOGIN/CTI_REQUEST_LOGIN_FEEDBACK 
        in Arbin docs for more info.
        &#39;&#39;&#39;
        class Client(MessageABC):
            msg_length = 74
            command_code = 0xEEAB0001

            msg_specific_template = {
                &#39;username&#39;: {
                    &#39;format&#39;: &#39;32s&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                    &#39;value&#39;: &#39;not a username&#39;
                },
                &#39;password&#39;: {
                    &#39;format&#39;: &#39;32s&#39;,
                    &#39;start_byte&#39;: 52,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                    &#39;value&#39;: &#39;not a password&#39;
                },
            }

        class Server(MessageABC):
            msg_length = 8678
            command_code = 0xEEBA0001

            msg_specific_template = {
                &#39;result&#39;: {
                    &#39;format&#39;: &#39;I&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;value&#39;: 1
                },
                &#39;ip_address&#39;: {
                    &#39;format&#39;: &#39;4s&#39;,
                    &#39;start_byte&#39;: 24,
                    &#39;value&#39;: &#34;0000&#34;,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
                &#39;cycler_sn&#39;: {
                    &#39;format&#39;: &#39;16s&#39;,
                    &#39;start_byte&#39;: 28,
                    &#39;value&#39;: &#39;00000000&#39;,
                    &#39;text_encoding&#39;: &#39;ascii&#39;,
                },
                &#39;note&#39;: {
                    &#39;format&#39;: &#39;256s&#39;,
                    &#39;start_byte&#39;: 44,
                    &#39;value&#39;: &#39;00000000&#39;,
                    &#39;text_encoding&#39;: &#39;ascii&#39;,
                },
                &#39;nick_name&#39;: {
                    # Stored as wchar_t[1024]. Each wchar_t is 2 bytes, twice as big as standard char in Python
                    &#39;format&#39;: &#39;2048s&#39;,
                    &#39;start_byte&#39;: 300,
                    &#39;value&#39;: &#39;our nickname&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;location&#39;: {
                    &#39;format&#39;: &#39;2048s&#39;,
                    &#39;start_byte&#39;: 2348,
                    &#39;value&#39;: &#39;our location&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;emergency_contact&#39;: {
                    &#39;format&#39;: &#39;2048s&#39;,
                    &#39;start_byte&#39;: 4396,
                    &#39;value&#39;: &#39;our location&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;other_comments&#39;: {
                    &#39;format&#39;: &#39;2048s&#39;,
                    &#39;start_byte&#39;: 6444,
                    &#39;value&#39;: &#39;our location&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;email&#39;: {
                    &#39;format&#39;: &#39;128s&#39;,
                    &#39;start_byte&#39;: 8492,
                    &#39;value&#39;: &#39;our location&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;call&#39;: {
                    &#39;format&#39;: &#39;32s&#39;,
                    &#39;start_byte&#39;: 8620,
                    &#39;value&#39;: &#39;our location&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;itac&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 8652,
                    &#39;value&#39;: 0
                },
                &#39;version&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 8656,
                    &#39;value&#39;: 0
                },
                &#39;allow_control&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 8660,
                    &#39;value&#39;: 0
                },
                &#39;num_channels&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 8664,
                    &#39;value&#39;: 0
                },
                &#39;user_type&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 8668,
                    &#39;value&#39;: 1,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;picture_length&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 8672,
                    &#39;value&#39;: 0,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
            }

            login_result_dict = {
                0: &#34;should not see this&#34;,
                1: &#34;success&#34;,
                2: &#34;fail&#34;,
                3: &#34;already logged in&#34;
            }

            @classmethod
            def unpack(cls, msg_bin: bytearray) -&gt; dict:
                &#34;&#34;&#34;
                Same as the parent method, but converts the result based on the
                login_result_dict.

                Parameters
                ----------
                msg_bin : bytearray
                    The message to unpack.

                Returns
                -------
                msg_dict : dict
                    The message with items decoded into a dictionary
                &#34;&#34;&#34;
                msg_dict = super().unpack(msg_bin)
                msg_dict[&#39;result&#39;] = cls.login_result_dict[msg_dict[&#39;result&#39;]]
                return msg_dict

    class ChannelInfo:
        &#39;&#39;&#39;
        Message for getting channel info from cycler. See
        CTI_REQUEST_GET_CHANNELS_INFO/CTI_REQUEST_GET_CHANNELS_INFO_FEED_BACK 
        in Arbin docs for more info.
        &#39;&#39;&#39;
        class Client(MessageABC):
            msg_length = 50
            command_code = 0xEEAB0003

            msg_specific_template = {
                &#39;channel&#39;: {
                    &#39;format&#39;: &#39;&lt;h&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;value&#39;: 0
                },
                &#39;channel_selection&#39;: {
                    &#39;format&#39;: &#39;&lt;h&#39;,
                    &#39;start_byte&#39;: 22,
                    &#39;value&#39;: 1
                },
                &#39;aux_options&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 24,
                    &#39;value&#39;: 0x00
                },
                &#39;reserved&#39;: {
                    &#39;format&#39;: &#39;32s&#39;,
                    &#39;start_byte&#39;: 28,
                    &#39;value&#39;: &#39;&#39;.join([&#39;\0&#39; for i in range(32)]),
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
            }

        class Server(MessageABC):

            # Default message length for 1 channel with no aux readings. Will be larger as those grow.
            msg_length = 1779
            command_code = 0xEEBA0003

            msg_specific_template = {
                &#39;number_of_channels&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;value&#39;: 1
                },
                &#39;channel&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 24,
                    &#39;value&#39;: 0
                },
                &#39;status&#39;: {
                    &#39;format&#39;: &#39;&lt;h&#39;,
                    &#39;start_byte&#39;: 28,
                    &#39;value&#39;: 0x00
                },
                &#39;comm_failure&#39;: {
                    &#39;format&#39;: &#39;&lt;B&#39;,
                    &#39;start_byte&#39;: 30,
                    &#39;value&#39;: 0
                },
                &#39;schedule&#39;: {
                    # Stored as wchar_t[200]. Each wchar_t is 2 bytes, twice as big as standard char in Python
                    &#39;format&#39;: &#39;400s&#39;,
                    &#39;start_byte&#39;: 31,
                    &#39;value&#39;: &#39;fake_schedule&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;testname&#39;: {
                    # Stored as wchar_t[72]
                    &#39;format&#39;: &#39;144s&#39;,
                    &#39;start_byte&#39;: 431,
                    &#39;value&#39;: &#39;fake_testname&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;exit_condition&#39;: {
                    &#39;format&#39;: &#39;100s&#39;,
                    &#39;start_byte&#39;: 575,
                    &#39;value&#39;: &#39;none&#39;,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
                &#39;step_and_cycle_format&#39;: {
                    &#39;format&#39;: &#39;64s&#39;,
                    &#39;start_byte&#39;: 675,
                    &#39;value&#39;: &#39;none&#39;,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
                # Stored as wchar_t[72]
                &#39;barcode&#39;: {
                    &#39;format&#39;: &#39;144s&#39;,
                    &#39;start_byte&#39;: 739,
                    &#39;value&#39;: &#39;none&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16&#39;,
                },
                # Stored as wchar_t[72]
                &#39;can_config_name&#39;: {
                    &#39;format&#39;: &#39;400s&#39;,
                    &#39;start_byte&#39;: 883,
                    &#39;value&#39;: &#39;none&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16&#39;,
                },
                # Stored as wchar_t[72]
                &#39;smb_config_name&#39;: {
                    &#39;format&#39;: &#39;400s&#39;,
                    &#39;start_byte&#39;: 1283,
                    &#39;value&#39;: &#39;none&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16&#39;,
                },
                &#39;master_channel&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1683,
                    &#39;value&#39;: 0,
                },
                &#39;test_time_s&#39;: {
                    &#39;format&#39;: &#39;&lt;d&#39;,
                    &#39;start_byte&#39;: 1685,
                    &#39;value&#39;: 0,
                },
                &#39;step_time_s&#39;: {
                    &#39;format&#39;: &#39;&lt;d&#39;,
                    &#39;start_byte&#39;: 1693,
                    &#39;value&#39;: 0,
                },
                &#39;voltage_v&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1701,
                    &#39;value&#39;: 0,
                },
                &#39;current_a&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1705,
                    &#39;value&#39;: 0,
                },
                &#39;power_w&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1709,
                    &#39;value&#39;: 0,
                },
                &#39;charge_capacity_ah&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1713,
                    &#39;value&#39;: 0,
                },
                &#39;discharge_capacity_ah&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1717,
                    &#39;value&#39;: 0,
                },
                &#39;charge_energy_wh&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1721,
                    &#39;value&#39;: 0,
                },
                &#39;discharge_energy_wh&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1725,
                    &#39;value&#39;: 0,
                },
                &#39;internal_resistance_ohm&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1729,
                    &#39;value&#39;: 0,
                },
                &#39;dvdt_vbys&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1733,
                    &#39;value&#39;: 0,
                },
                &#39;acr_ohm&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1737,
                    &#39;value&#39;: 0,
                },
                &#39;aci_ohm&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1741,
                    &#39;value&#39;: 0,
                },
                &#39;aci_phase_degrees&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1745,
                    &#39;value&#39;: 0,
                },
                &#39;aux_voltage_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1749,
                    &#39;value&#39;: 0,
                },
                &#39;aux_temperature_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1751,
                    &#39;value&#39;: 0,
                },
                &#39;aux_pressure_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1753,
                    &#39;value&#39;: 0,
                },
                &#39;aux_external_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1755,
                    &#39;value&#39;: 0,
                },
                &#39;aux_flow_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1757,
                    &#39;value&#39;: 0,
                },
                &#39;aux_ao_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1759,
                    &#39;value&#39;: 0,
                },
                &#39;aux_di_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1761,
                    &#39;value&#39;: 0,
                },
                &#39;aux_do_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1763,
                    &#39;value&#39;: 0,
                },
                &#39;aux_humidity_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1765,
                    &#39;value&#39;: 0,
                },
                &#39;aux_safety_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1767,
                    &#39;value&#39;: 0,
                },
                &#39;aux_ph_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1769,
                    &#39;value&#39;: 0,
                },
                &#39;aux_density_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1771,
                    &#39;value&#39;: 0,
                },
                &#39;bms_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1773,
                    &#39;value&#39;: 0,
                },
                &#39;smb_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1775,
                    &#39;value&#39;: 0,
                },
            }

            # List of staus codes. Each index in the corresponding status code.
            status_code_dict = {
                0: &#39;Idle&#39;,
                1: &#39;Transition&#39;,
                2: &#39;Charge&#39;,
                3: &#39;Disharge&#39;,
                4: &#39;Rest&#39;,
                5: &#39;Wait&#39;,
                6: &#39;External Charge&#39;,
                7: &#39;Calibration&#39;,
                8: &#39;Unsafe&#39;,
                9: &#39;Pulse&#39;,
                10: &#39;Internal Resistance&#39;,
                11: &#39;AC Impedance&#39;,
                12: &#39;ACI Cell&#39;,
                13: &#39;Test Settings&#39;,
                14: &#39;Error&#39;,
                15: &#39;Finished&#39;,
                16: &#39;Volt Meter&#39;,
                17: &#39;Waiting for ACS&#39;,
                18: &#39;Pause&#39;,
                19: &#39;Empty&#39;,
                20: &#39;Idle from MCU&#39;,
                21: &#39;Start&#39;,
                22: &#39;Running&#39;,
                23: &#39;Step Transfer&#39;,
                24: &#39;Resume&#39;,
                25: &#39;Go Pause&#39;,
                26: &#39;Go Stop&#39;,
                27: &#39;Go Next Step&#39;,
                28: &#39;Online Update&#39;,
                29: &#39;DAQ Memory Unsafe&#39;,
                30: &#39;ACR&#39;
            }

            @classmethod
            def unpack(cls, msg_bin: bytearray) -&gt; dict:
                &#34;&#34;&#34;
                Same as the parent method, but uses aux counts to unpack aux readings

                Parameters
                ----------
                msg_bin : bytearry
                    The message to unpack.

                Returns
                -------
                msg_dict : dict
                    The message with items decoded into a dictionary
                &#34;&#34;&#34;
                msg_dict = super().unpack(msg_bin)
                msg_dict = cls.aux_readings_parser(
                    msg_dict, msg_bin, starting_aux_idx=1777)
                msg_dict[&#39;status&#39;] = cls.status_code_dict[msg_dict[&#39;status&#39;]]
                return msg_dict

            @classmethod
            def pack(cls, msg_values={}) -&gt; bytearray:
                &#34;&#34;&#34;
                Same as parent method, but handles packing aux measurements.

                Parameters
                ----------
                msg_values : dict
                    A dictionary detailing which default values in the message temple should be 
                    updated.

                Returns
                -------
                msg : bytearray
                    Packed response message.
                &#34;&#34;&#34;
                # TODO : Modify so that we can aux values can be packed.
                msg_bin = super().pack(msg_values)
                return msg_bin

            @classmethod
            def aux_readings_parser(cls, msg_dict: dict, msg_bin: bytearray, starting_aux_idx=1777):
                &#34;&#34;&#34;
                Parses the auxiliary readings in msg_bin based on the aux readings
                counts in msg_dict. Aux readings are then added as items to the msg_dict. 

                Parameters
                ----------
                msg_dict : dict
                    A dictionary containing the aux readings counts (aux_voltage_count, aux_voltage_count, etc)
                msg_bin : bytearray
                    The message to unpack as a byte array.
                starting_aux_idx : int
                    The starting index in the msg_bin for aux readings. 1777 in single channel messages

                Returns
                -------
                msg_dict : dict
                    The message with items decoded into a dictionary
                &#34;&#34;&#34;
                aux_lists = []

                aux_count_name_list = [
                    &#39;aux_voltage_count&#39;,
                    &#39;aux_temperature_count&#39;,
                    &#39;aux_pressure_count&#39;,
                    &#39;aux_external_count&#39;,
                    &#39;aux_flow_count&#39;,
                    &#39;aux_ao_count&#39;,
                    &#39;aux_di_count&#39;,
                    &#39;aux_do_count&#39;,
                    &#39;aux_humidity_count&#39;,
                    &#39;aux_safety_count&#39;,
                    &#39;aux_ph_count&#39;,
                    &#39;aux_density_count&#39;
                ]

                # Generate a list of readings for each aux reading.
                # If count is non-zero then genreate a aux_reading and aux_reading_dt list of that length
                # Else, generate empty lists for the aux_reading and aux_reading_dt
                for aux_count_name in aux_count_name_list:
                    aux_reading_name = re.split(&#39;_count&#39;, aux_count_name)[0]
                    aux_dt_name = aux_reading_name + &#39;_dt&#39;
                    if msg_dict[aux_count_name]:
                        msg_dict[aux_reading_name] = [0 for x in range(
                            msg_dict[aux_count_name])]
                        msg_dict[aux_dt_name] = [0 for x in range(
                            msg_dict[aux_count_name])]
                        aux_lists.append(
                            [msg_dict[aux_reading_name], msg_dict[aux_dt_name]])
                    else:
                        msg_dict[aux_reading_name] = []
                        msg_dict[aux_dt_name] = []

                # For aux readings that have a measurements, add them to the respective reading list.
                current_aux_idx = starting_aux_idx
                for readings_list in aux_lists:
                    for i in range(0, len(readings_list[0])):
                        # The first list in reading list is reading itself
                        readings_list[0][i] = struct.unpack(
                            &#39;&lt;f&#39;, msg_bin[current_aux_idx:current_aux_idx+4])[0]
                        # The second reading in the list is the dt value.
                        readings_list[1][i] = struct.unpack(
                            &#39;&lt;f&#39;, msg_bin[current_aux_idx+4:current_aux_idx+8])[0]
                        current_aux_idx += 8

                return msg_dict

    class AssignSchedule:
        &#39;&#39;&#39;
        Message for assiging a schedule to a specific channel. See
        THIRD_PARTY_ASSIGN_SCHEDULE/THIRD_PARTY_ASSIGN_SCHEDULE_FEEDBACK 
        in Arbin docs for more info.
        &#39;&#39;&#39;
        class Client(MessageABC):
            msg_length = 659
            command_code = 0xBB210001

            msg_specific_template = {
                &#39;channel&#39;: {
                    &#39;format&#39;: &#39;i&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;value&#39;: 0
                },
                # Always 0x00 for PyCTI since we only work with single channels
                &#39;assign_all_channels&#39;: {
                    &#39;format&#39;: &#39;1s&#39;,
                    &#39;start_byte&#39;: 24,
                    &#39;value&#39;: &#39;\0&#39;,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
                &#39;schedule&#39;: {
                    # Stored as wchar_t[200]. Each wchar_t is 2 bytes, twice as big as standard char in Python
                    &#39;format&#39;: &#39;400s&#39;,
                    &#39;start_byte&#39;: 25,
                    &#39;value&#39;: &#39;fake_schedule&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;test_capacity_ah&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 425,
                    &#39;value&#39;: 1.0,
                },
                &#39;barcode&#39;: {
                    &#39;format&#39;: &#39;144s&#39;,
                    &#39;start_byte&#39;: 429,
                    &#39;value&#39;: &#39;&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;user_variable_1&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 573,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_2&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 577,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_3&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 581,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_4&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 585,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_5&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 589,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_6&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 593,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_7&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 597,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_8&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 601,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_9&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 605,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_10&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 609,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_11&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 613,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_12&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 617,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_13&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 621,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_14&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 625,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_15&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 629,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_16&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 633,
                    &#39;value&#39;: 1.0,
                },
                &#39;reserved&#39;: {
                    &#39;format&#39;: &#39;32s&#39;,
                    &#39;start_byte&#39;: 637,
                    &#39;value&#39;: &#39;&#39;.join([&#39;\0&#39; for i in range(32)]),
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
            }

        class Server(MessageABC):
            msg_length = 128
            command_code = 0xBB120001

            msg_specific_template = {
                &#39;channel&#39;: {
                    &#39;format&#39;: &#39;i&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;value&#39;: 0
                },
                &#39;result&#39;: {
                    &#39;format&#39;: &#39;c&#39;,
                    &#39;start_byte&#39;: 24,
                    &#39;value&#39;: &#39;\0&#39;,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
                &#39;reserved&#39;: {
                    &#39;format&#39;: &#39;101s&#39;,
                    &#39;start_byte&#39;: 25,
                    &#39;value&#39;: &#39;&#39;.join([&#39;\0&#39; for i in range(101)]),
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
            }

            assign_schedule_feedback_codes = {
                0: &#39;success&#39;,
                16: &#39;channel does not exist&#39;,
                17: &#39;Monitor window in use at the moment&#39;,
                18: &#39;Schedule name cannot be empty&#39;,
                19: &#39;Schedule name not found&#39;,
                20: &#39;Channel is running&#39;,
                21: &#39;Channel is downloading another schedule currently&#39;,
                22: &#39;Cannot assign schedule when batch file is open&#39;,
                23: &#39;Assign failed&#39;,
                24: &#39;Not used: User should never see this&#39;,
            }

            @classmethod
            def unpack(cls, msg_bin: bytearray) -&gt; dict:
                &#34;&#34;&#34;
                Same as the parent method, but converts the result based on the
                assign_schedule_feedback_codes.

                Parameters
                ----------
                msg_bin : bytearray
                    The message to unpack.

                Returns
                -------
                msg_dict : dict
                    The message with items decoded into a dictionary
                &#34;&#34;&#34;
                msg_dict = super().unpack(msg_bin)
                msg_dict[&#39;result&#39;] = cls.assign_schedule_feedback_codes[
                    ord(msg_dict[&#39;result&#39;])]
                return msg_dict

    class StartSchedule:
        &#39;&#39;&#39;
        Message for assigning a schedule to a specific channel. See
        THIRD_PARTY_START_SCHEDULE/THIRD_PARTY_START_SCHEDULE_FEEDBACK 
        in Arbin docs for more info.
        &#39;&#39;&#39;
        class Client(MessageABC):
            msg_length = 160
            command_code = 0xBB320004

            msg_specific_template = {
                &#39;test_name&#39;: {
                    # Read as wchar_t which has length of 2 bytes each.
                    &#39;format&#39;: &#39;144s&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;value&#39;: &#39;pycti test name&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;num_channels_to_start&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 164,
                    &#39;value&#39;: 1
                },
                &#39;channel&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 168,
                    &#39;value&#39;: 0
                },
            }

        class Server(MessageABC):
            msg_length = 128
            command_code = 0XBB230004

            msg_specific_template = {
                &#39;channel&#39;: {
                    &#39;format&#39;: &#39;I&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;value&#39;: 0
                },
                &#39;result&#39;: {
                    &#39;format&#39;: &#39;c&#39;,
                    &#39;start_byte&#39;: 24,
                    &#39;value&#39;: &#39;\0&#39;,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
                &#39;reserved&#39;: {
                    &#39;format&#39;: &#39;101s&#39;,
                    &#39;start_byte&#39;: 25,
                    &#39;value&#39;: &#39;&#39;.join([&#39;\0&#39; for i in range(101)]),
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
            }

            start_test_feedback_codes = {
                0: &#39;success&#39;,
                16: &#39;Invalid channel index&#39;,
                17: &#39;There is a user controlling the monitor window (Start/Resume channel window is open)&#39;,
                18: &#39;Requested channel is running or unsafe&#39;,
                19: &#39;Channel not connected to DAQ&#39;,
                20: &#39;Schedule not compatible with current system configuration&#39;,
                21: &#39;No schedule assigned to channel&#39;,
                22: &#39;Schedule version does not match current version of MITS&#39;,
                23: &#39;Not used: User should never see this&#39;,
                24: &#39;Not used: User should never see this&#39;,
                25: &#39;Invalid step number&#39;,
                26: &#39;Not used: User should never see this&#39;,
                27: &#39;Invalid auxiliary count in schedule&#39;,
                28: &#39;Invalid build in auxiliary count&#39;,
                29: &#39;Not used: User should never see this&#39;,
                30: &#39;Check Aux Test Setting tab&#39;,
                31: &#39;No selected channels&#39;,
                32: &#39;Not used: User should never see this&#39;,
                33: &#39;DAQ still downloading schedule&#39;,
                34: &#39;Error querying database (database connection closed most likely)&#39;,
                35: &#39;Testname cannot be empty&#39;,
                36: &#39;Invalid step number&#39;,
                37: &#39;Invalid parallel channel number&#39;,
                38: &#39;Schedule safety precheck failed&#39;,
                39: &#39;Not used: User should never see this&#39;,
                40: &#39;Battery simulation error&#39;,
            }

            @classmethod
            def unpack(cls, msg_bin: bytearray) -&gt; dict:
                &#34;&#34;&#34;
                Same as the parent method, but converts the result based on the
                start_test_feedback_codes.

                Parameters
                ----------
                msg_bin : bytearray
                    The message to unpack.

                Returns
                -------
                msg_dict : dict
                    The message with items decoded into a dictionary
                &#34;&#34;&#34;
                msg_dict = super().unpack(msg_bin)
                msg_dict[&#39;result&#39;] = cls.start_test_feedback_codes[
                    ord(msg_dict[&#39;result&#39;])]
                return msg_dict

    class StopSchedule:
        &#39;&#39;&#39;
        Message for stopping a test on a specific channel. See
        THIRD_PARTY_STOP_SCHEDULE/THIRD_PARTY_STOP_SCHEDULE_FEEDBACK 
        in Arbin docs for more info.
        &#39;&#39;&#39;
        class Client(MessageABC):
            msg_length = 116
            command_code = 0xBB310001

            msg_specific_template = {
                &#39;channel&#39;: {
                    &#39;format&#39;: &#39;I&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;value&#39;: 0
                },
                # Always 0x00, others all channels are stopped.
                &#39;stop_all_channels&#39;: {
                    &#39;format&#39;: &#39;1s&#39;,
                    &#39;start_byte&#39;: 24,
                    &#39;value&#39;: &#39;\0&#39;,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
                &#39;reserved&#39;: {
                    &#39;format&#39;: &#39;101s&#39;,
                    &#39;start_byte&#39;: 25,
                    &#39;value&#39;: &#39;&#39;.join([&#39;\0&#39; for i in range(101)]),
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
            }

        class Server(MessageABC):
            msg_length = 128
            command_code = 0XBB130001

            msg_specific_template = {
                &#39;channel&#39;: {
                    &#39;format&#39;: &#39;I&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;value&#39;: 0
                },
                &#39;result&#39;: {
                    &#39;format&#39;: &#39;c&#39;,
                    &#39;start_byte&#39;: 24,
                    &#39;value&#39;: &#39;\0&#39;,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
                &#39;reserved&#39;: {
                    &#39;format&#39;: &#39;101s&#39;,
                    &#39;start_byte&#39;: 25,
                    &#39;value&#39;: &#39;&#39;.join([&#39;\0&#39; for i in range(101)]),
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
            }

            stop_test_feedback_codes = {
                0: &#39;success&#39;,
                16: &#39;Channel index does not exist&#39;,
                17: &#39;Someone else is controlling monitor window at the moment&#39;,
                18: &#39;Not used: User should never see this&#39;,
                19: &#39;Not used: User should never see this&#39;,
            }

            @classmethod
            def unpack(cls, msg_bin: bytearray) -&gt; dict:
                &#34;&#34;&#34;
                Same as the parent method, but converts the result based on the
                stop_test_feedback_codes.

                Parameters
                ----------
                msg_bin : bytearray
                    The message to unpack.

                Returns
                -------
                msg_dict : dict
                    The message with items decoded into a dictionary
                &#34;&#34;&#34;
                msg_dict = super().unpack(msg_bin)
                msg_dict[&#39;result&#39;] = cls.stop_test_feedback_codes[
                    ord(msg_dict[&#39;result&#39;])]
                return msg_dict

    class SetMetaVariable:
        &#39;&#39;&#39;
        Message for setting meta variables. 
        THIRD_PARTY_SET_MV_VALUE/THIRD_PARTY_SET_MV_VALUE_FEEDBACK 
        in Arbin docs for more info.
        &#39;&#39;&#39;
        class Client(MessageABC):
            msg_length = 62
            command_code = 0xBB150001

            msg_specific_template = {
                &#39;channel&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;value&#39;: 0
                },
                # The only mv_type allowed for CTI is 1
                &#39;mv_type&#39;: {
                    &#39;format&#39;: &#39;&lt;i&#39;,
                    &#39;start_byte&#39;: 24,
                    &#39;value&#39;: 1
                },
                # This determines which meta variable is set. Defaults to MV 1.
                &#39;mv_meta_code&#39;: {
                    &#39;format&#39;: &#39;&lt;i&#39;,
                    &#39;start_byte&#39;: 28,
                    &#39;value&#39;: 52,
                },
                &#39;reserved_1&#39;: {
                    &#39;format&#39;: &#39;16s&#39;,
                    &#39;start_byte&#39;: 32,
                    &#39;value&#39;: &#39;&#39;.join([&#39;\0&#39; for i in range(16)]),
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
                # The only value type allowed for CTI is 1, float.
                &#39;mv_value_type&#39;: {
                    &#39;format&#39;: &#39;&lt;i&#39;,
                    &#39;start_byte&#39;: 48,
                    &#39;value&#39;: 1
                },
                &#39;mv_data&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 52,
                    &#39;value&#39;: 1
                },
                &#39;reserved_2&#39;: {
                    &#39;format&#39;: &#39;16s&#39;,
                    &#39;start_byte&#39;: 56,
                    &#39;value&#39;: &#39;&#39;.join([&#39;\0&#39; for i in range(16)]),
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
            }

            # Specifies the code for each variable. E.g. MV_UD1 has a code of 52
            mv_channel_codes = {
                1: 52,
                2: 53,
                3: 54,
                4: 55,
                5: 105,
                6: 106,
                7: 107,
                8: 108,
                9: 109,
                10: 110,
                11: 111,
                12: 112,
                13: 113,
                14: 114,
                15: 115,
                16: 116,
            }

        class Server(MessageABC):
            msg_length = 128
            command_code = 0XBB510001

            msg_specific_template = {
                &#39;channel&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;value&#39;: 0
                },
                &#39;result&#39;: {
                    &#39;format&#39;: &#39;c&#39;,
                    &#39;start_byte&#39;: 24,
                    &#39;value&#39;: &#39;\0&#39;,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
                &#39;reserved&#39;: {
                    &#39;format&#39;: &#39;101s&#39;,
                    &#39;start_byte&#39;: 25,
                    &#39;value&#39;: &#39;&#39;.join([&#39;\0&#39; for i in range(101)]),
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
            }

            mv_result_decoder = {
                0: &#39;success&#39;,
                16: &#39;Set MV Failure&#39;,
                17: &#39;Channel is not running&#39;,
                18: &#39;Meta code does not exist&#39;
            }

            @classmethod
            def unpack(cls, msg_bin: bytearray) -&gt; dict:
                &#34;&#34;&#34;
                Same as the parent method, but converts the result based on the
                stop_test_feedback_codes.

                Parameters
                ----------
                msg_bin : bytearry
                    The message to unpack.

                Returns
                -------
                msg_dict : dict
                    The message with items decoded into a dictionary
                &#34;&#34;&#34;
                msg_dict = super().unpack(msg_bin)

                msg_dict[&#39;result&#39;] = cls.mv_result_decoder[
                    ord(msg_dict[&#39;result&#39;])]

                return msg_dict</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pycti.messages.MessageABC"><code class="flex name class">
<span>class <span class="ident">MessageABC</span></span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MessageABC(ABC):

    # The length of the message. Should be overwritten in child class
    msg_length = 0

    # The message command code. Should be overwritten in child class
    command_code = 0x00

    # Template that is specific to each message type. Should be overwritten in child class
    msg_specific_template = {}

    # Base message template that is common for all messages
    base_template = {
        &#39;header&#39;: {
            &#39;format&#39;: &#39;&lt;Q&#39;,
            &#39;start_byte&#39;: 0,
            &#39;value&#39;: 0x11DDDDDDDDDDDDDD
        },
        &#39;msg_length&#39;: {
            &#39;format&#39;: &#39;&lt;L&#39;,
            &#39;start_byte&#39;: 8,
            &#39;value&#39;: 0
        },
        &#39;command_code&#39;: {
            &#39;format&#39;: &#39;&lt;L&#39;,
            &#39;start_byte&#39;: 12,
            &#39;value&#39;: 0x00000000
        },
        &#39;extended_command_code&#39;: {
            &#39;format&#39;: &#39;&lt;L&#39;,
            &#39;start_byte&#39;: 16,
            &#39;value&#39;: 0x00000000
        },
    }

    @classmethod
    def unpack(cls, msg_bin: bytearray) -&gt; dict:
        &#34;&#34;&#34;
        Parses the passed message and decodes it with the msg_encoding dict.
        Each key in the output message will have name of the key from the 
        msg_encoding dictionary.

        Parameters
        ----------
        msg_bin : bytearry
            The message to unpack.

        Returns
        -------
        decoded_msg_dict : dict
            The message items decoded into a dictionary.
        &#34;&#34;&#34;
        decoded_msg_dict = {}

        # Create a template to unpack message with
        template = {**deepcopy(cls.base_template),
                   **deepcopy(cls.msg_specific_template)}

        for item_name, item in template.items():
            start_idx = item[&#39;start_byte&#39;]
            end_idx = item[&#39;start_byte&#39;] + struct.calcsize(item[&#39;format&#39;])
            decoded_msg_dict[item_name] = struct.unpack(
                item[&#39;format&#39;], msg_bin[start_idx:end_idx])[0]

            # Decode and strip trailing 0x00s from strings.
            if item[&#39;format&#39;].endswith(&#39;s&#39;):
                decoded_msg_dict[item_name] = decoded_msg_dict[item_name].decode(
                    item[&#39;text_encoding&#39;]).rstrip(&#39;\x00&#39;)

        if decoded_msg_dict[&#39;command_code&#39;] != cls.command_code:
            logger.warning(
                f&#39;Decoded command code {decoded_msg_dict[&#34;command_code&#34;]} does not match what was expected!&#39;)

        if decoded_msg_dict[&#39;msg_length&#39;] != cls.msg_length:
            logger.warning(
                f&#39;Decoded message length {decoded_msg_dict[&#34;msg_length&#34;]} does not match what was expected!&#39;)

        return decoded_msg_dict

    @classmethod
    def pack(cls, msg_values={}) -&gt; bytearray:
        &#34;&#34;&#34;
        Packs a message based on the message encoding given in the msg_specific_template
        dictionary. Values can be substituted for default values if they are included 
        in the `msg_values` argument.

        Parameters
        ----------
        msg_values : dict
            A dictionary detailing which default values in the message temple should be 
            updated.

        Returns
        -------
        msg_bin : bytearray
            Packed response message.
        &#34;&#34;&#34;
        # Create a template to build messages from
        template = {**deepcopy(cls.base_template),
                   **deepcopy(cls.msg_specific_template)}

        # Update the template with message specific length and command code
        template[&#39;msg_length&#39;][&#39;value&#39;] = cls.msg_length
        template[&#39;command_code&#39;][&#39;value&#39;] = cls.command_code

        # Create a message bytearray that will be loaded with message contents
        msg_bin = bytearray(template[&#39;msg_length&#39;][&#39;value&#39;])

        # Update default message values with those in the passed msg_values dict
        for key in msg_values.keys():
            if key in template.keys():
                template[key][&#39;value&#39;] = msg_values[key]
            else:
                logger.warning(
                    f&#39;Key name {key} was not found in msg_encoding!&#39;)

        # Pack each item in template. If packing any item fails then abort packing.
        for item_name, item in template.items():
            logger.debug(f&#39;Packing item {item_name}&#39;)
            try:
                if item[&#39;format&#39;].endswith(&#39;s&#39;) or item[&#39;format&#39;].endswith(&#39;c&#39;):
                    packed_item = struct.pack(
                        item[&#39;format&#39;],
                        item[&#39;value&#39;].encode(item[&#39;text_encoding&#39;]))
                else:
                    packed_item = struct.pack(
                        item[&#39;format&#39;], item[&#39;value&#39;])
            except struct.error as e:
                logger.error(
                    f&#39;Error packing {item_name} with fields {item}!&#39;)
                logger.error(e)
                msg_bin = bytearray([])
                break

            start_idx = item[&#39;start_byte&#39;]
            end_idx = item[&#39;start_byte&#39;] + struct.calcsize(item[&#39;format&#39;])
            msg_bin[start_idx:end_idx] = packed_item

        # Append a checksum to the end of the message
        if msg_bin:
            msg_bin += struct.pack(&#39;&lt;H&#39;, sum(msg_bin))

        return msg_bin</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pycti.messages.Msg.AssignSchedule.Client</li>
<li>pycti.messages.Msg.AssignSchedule.Server</li>
<li>pycti.messages.Msg.ChannelInfo.Client</li>
<li>pycti.messages.Msg.ChannelInfo.Server</li>
<li>pycti.messages.Msg.Login.Client</li>
<li>pycti.messages.Msg.Login.Server</li>
<li>pycti.messages.Msg.SetMetaVariable.Client</li>
<li>pycti.messages.Msg.SetMetaVariable.Server</li>
<li>pycti.messages.Msg.StartSchedule.Client</li>
<li>pycti.messages.Msg.StartSchedule.Server</li>
<li>pycti.messages.Msg.StopSchedule.Client</li>
<li>pycti.messages.Msg.StopSchedule.Server</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pycti.messages.MessageABC.base_template"><code class="name">var <span class="ident">base_template</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.messages.MessageABC.command_code"><code class="name">var <span class="ident">command_code</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.messages.MessageABC.msg_length"><code class="name">var <span class="ident">msg_length</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.messages.MessageABC.msg_specific_template"><code class="name">var <span class="ident">msg_specific_template</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="pycti.messages.MessageABC.pack"><code class="name flex">
<span>def <span class="ident">pack</span></span>(<span>msg_values={}) ‑> bytearray</span>
</code></dt>
<dd>
<div class="desc"><p>Packs a message based on the message encoding given in the msg_specific_template
dictionary. Values can be substituted for default values if they are included
in the <code>msg_values</code> argument.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>msg_values</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary detailing which default values in the message temple should be
updated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>msg_bin</code></strong> :&ensp;<code>bytearray</code></dt>
<dd>Packed response message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def pack(cls, msg_values={}) -&gt; bytearray:
    &#34;&#34;&#34;
    Packs a message based on the message encoding given in the msg_specific_template
    dictionary. Values can be substituted for default values if they are included 
    in the `msg_values` argument.

    Parameters
    ----------
    msg_values : dict
        A dictionary detailing which default values in the message temple should be 
        updated.

    Returns
    -------
    msg_bin : bytearray
        Packed response message.
    &#34;&#34;&#34;
    # Create a template to build messages from
    template = {**deepcopy(cls.base_template),
               **deepcopy(cls.msg_specific_template)}

    # Update the template with message specific length and command code
    template[&#39;msg_length&#39;][&#39;value&#39;] = cls.msg_length
    template[&#39;command_code&#39;][&#39;value&#39;] = cls.command_code

    # Create a message bytearray that will be loaded with message contents
    msg_bin = bytearray(template[&#39;msg_length&#39;][&#39;value&#39;])

    # Update default message values with those in the passed msg_values dict
    for key in msg_values.keys():
        if key in template.keys():
            template[key][&#39;value&#39;] = msg_values[key]
        else:
            logger.warning(
                f&#39;Key name {key} was not found in msg_encoding!&#39;)

    # Pack each item in template. If packing any item fails then abort packing.
    for item_name, item in template.items():
        logger.debug(f&#39;Packing item {item_name}&#39;)
        try:
            if item[&#39;format&#39;].endswith(&#39;s&#39;) or item[&#39;format&#39;].endswith(&#39;c&#39;):
                packed_item = struct.pack(
                    item[&#39;format&#39;],
                    item[&#39;value&#39;].encode(item[&#39;text_encoding&#39;]))
            else:
                packed_item = struct.pack(
                    item[&#39;format&#39;], item[&#39;value&#39;])
        except struct.error as e:
            logger.error(
                f&#39;Error packing {item_name} with fields {item}!&#39;)
            logger.error(e)
            msg_bin = bytearray([])
            break

        start_idx = item[&#39;start_byte&#39;]
        end_idx = item[&#39;start_byte&#39;] + struct.calcsize(item[&#39;format&#39;])
        msg_bin[start_idx:end_idx] = packed_item

    # Append a checksum to the end of the message
    if msg_bin:
        msg_bin += struct.pack(&#39;&lt;H&#39;, sum(msg_bin))

    return msg_bin</code></pre>
</details>
</dd>
<dt id="pycti.messages.MessageABC.unpack"><code class="name flex">
<span>def <span class="ident">unpack</span></span>(<span>msg_bin: bytearray) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the passed message and decodes it with the msg_encoding dict.
Each key in the output message will have name of the key from the
msg_encoding dictionary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>msg_bin</code></strong> :&ensp;<code>bytearry</code></dt>
<dd>The message to unpack.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>decoded_msg_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>The message items decoded into a dictionary.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def unpack(cls, msg_bin: bytearray) -&gt; dict:
    &#34;&#34;&#34;
    Parses the passed message and decodes it with the msg_encoding dict.
    Each key in the output message will have name of the key from the 
    msg_encoding dictionary.

    Parameters
    ----------
    msg_bin : bytearry
        The message to unpack.

    Returns
    -------
    decoded_msg_dict : dict
        The message items decoded into a dictionary.
    &#34;&#34;&#34;
    decoded_msg_dict = {}

    # Create a template to unpack message with
    template = {**deepcopy(cls.base_template),
               **deepcopy(cls.msg_specific_template)}

    for item_name, item in template.items():
        start_idx = item[&#39;start_byte&#39;]
        end_idx = item[&#39;start_byte&#39;] + struct.calcsize(item[&#39;format&#39;])
        decoded_msg_dict[item_name] = struct.unpack(
            item[&#39;format&#39;], msg_bin[start_idx:end_idx])[0]

        # Decode and strip trailing 0x00s from strings.
        if item[&#39;format&#39;].endswith(&#39;s&#39;):
            decoded_msg_dict[item_name] = decoded_msg_dict[item_name].decode(
                item[&#39;text_encoding&#39;]).rstrip(&#39;\x00&#39;)

    if decoded_msg_dict[&#39;command_code&#39;] != cls.command_code:
        logger.warning(
            f&#39;Decoded command code {decoded_msg_dict[&#34;command_code&#34;]} does not match what was expected!&#39;)

    if decoded_msg_dict[&#39;msg_length&#39;] != cls.msg_length:
        logger.warning(
            f&#39;Decoded message length {decoded_msg_dict[&#34;msg_length&#34;]} does not match what was expected!&#39;)

    return decoded_msg_dict</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.messages.Msg"><code class="flex name class">
<span>class <span class="ident">Msg</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Msg:
    class Login:
        &#39;&#39;&#39;
        Message for logging into Arbin cycler. See
        CTI_REQUEST_LOGIN/CTI_REQUEST_LOGIN_FEEDBACK 
        in Arbin docs for more info.
        &#39;&#39;&#39;
        class Client(MessageABC):
            msg_length = 74
            command_code = 0xEEAB0001

            msg_specific_template = {
                &#39;username&#39;: {
                    &#39;format&#39;: &#39;32s&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                    &#39;value&#39;: &#39;not a username&#39;
                },
                &#39;password&#39;: {
                    &#39;format&#39;: &#39;32s&#39;,
                    &#39;start_byte&#39;: 52,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                    &#39;value&#39;: &#39;not a password&#39;
                },
            }

        class Server(MessageABC):
            msg_length = 8678
            command_code = 0xEEBA0001

            msg_specific_template = {
                &#39;result&#39;: {
                    &#39;format&#39;: &#39;I&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;value&#39;: 1
                },
                &#39;ip_address&#39;: {
                    &#39;format&#39;: &#39;4s&#39;,
                    &#39;start_byte&#39;: 24,
                    &#39;value&#39;: &#34;0000&#34;,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
                &#39;cycler_sn&#39;: {
                    &#39;format&#39;: &#39;16s&#39;,
                    &#39;start_byte&#39;: 28,
                    &#39;value&#39;: &#39;00000000&#39;,
                    &#39;text_encoding&#39;: &#39;ascii&#39;,
                },
                &#39;note&#39;: {
                    &#39;format&#39;: &#39;256s&#39;,
                    &#39;start_byte&#39;: 44,
                    &#39;value&#39;: &#39;00000000&#39;,
                    &#39;text_encoding&#39;: &#39;ascii&#39;,
                },
                &#39;nick_name&#39;: {
                    # Stored as wchar_t[1024]. Each wchar_t is 2 bytes, twice as big as standard char in Python
                    &#39;format&#39;: &#39;2048s&#39;,
                    &#39;start_byte&#39;: 300,
                    &#39;value&#39;: &#39;our nickname&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;location&#39;: {
                    &#39;format&#39;: &#39;2048s&#39;,
                    &#39;start_byte&#39;: 2348,
                    &#39;value&#39;: &#39;our location&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;emergency_contact&#39;: {
                    &#39;format&#39;: &#39;2048s&#39;,
                    &#39;start_byte&#39;: 4396,
                    &#39;value&#39;: &#39;our location&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;other_comments&#39;: {
                    &#39;format&#39;: &#39;2048s&#39;,
                    &#39;start_byte&#39;: 6444,
                    &#39;value&#39;: &#39;our location&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;email&#39;: {
                    &#39;format&#39;: &#39;128s&#39;,
                    &#39;start_byte&#39;: 8492,
                    &#39;value&#39;: &#39;our location&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;call&#39;: {
                    &#39;format&#39;: &#39;32s&#39;,
                    &#39;start_byte&#39;: 8620,
                    &#39;value&#39;: &#39;our location&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;itac&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 8652,
                    &#39;value&#39;: 0
                },
                &#39;version&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 8656,
                    &#39;value&#39;: 0
                },
                &#39;allow_control&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 8660,
                    &#39;value&#39;: 0
                },
                &#39;num_channels&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 8664,
                    &#39;value&#39;: 0
                },
                &#39;user_type&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 8668,
                    &#39;value&#39;: 1,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;picture_length&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 8672,
                    &#39;value&#39;: 0,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
            }

            login_result_dict = {
                0: &#34;should not see this&#34;,
                1: &#34;success&#34;,
                2: &#34;fail&#34;,
                3: &#34;already logged in&#34;
            }

            @classmethod
            def unpack(cls, msg_bin: bytearray) -&gt; dict:
                &#34;&#34;&#34;
                Same as the parent method, but converts the result based on the
                login_result_dict.

                Parameters
                ----------
                msg_bin : bytearray
                    The message to unpack.

                Returns
                -------
                msg_dict : dict
                    The message with items decoded into a dictionary
                &#34;&#34;&#34;
                msg_dict = super().unpack(msg_bin)
                msg_dict[&#39;result&#39;] = cls.login_result_dict[msg_dict[&#39;result&#39;]]
                return msg_dict

    class ChannelInfo:
        &#39;&#39;&#39;
        Message for getting channel info from cycler. See
        CTI_REQUEST_GET_CHANNELS_INFO/CTI_REQUEST_GET_CHANNELS_INFO_FEED_BACK 
        in Arbin docs for more info.
        &#39;&#39;&#39;
        class Client(MessageABC):
            msg_length = 50
            command_code = 0xEEAB0003

            msg_specific_template = {
                &#39;channel&#39;: {
                    &#39;format&#39;: &#39;&lt;h&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;value&#39;: 0
                },
                &#39;channel_selection&#39;: {
                    &#39;format&#39;: &#39;&lt;h&#39;,
                    &#39;start_byte&#39;: 22,
                    &#39;value&#39;: 1
                },
                &#39;aux_options&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 24,
                    &#39;value&#39;: 0x00
                },
                &#39;reserved&#39;: {
                    &#39;format&#39;: &#39;32s&#39;,
                    &#39;start_byte&#39;: 28,
                    &#39;value&#39;: &#39;&#39;.join([&#39;\0&#39; for i in range(32)]),
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
            }

        class Server(MessageABC):

            # Default message length for 1 channel with no aux readings. Will be larger as those grow.
            msg_length = 1779
            command_code = 0xEEBA0003

            msg_specific_template = {
                &#39;number_of_channels&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;value&#39;: 1
                },
                &#39;channel&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 24,
                    &#39;value&#39;: 0
                },
                &#39;status&#39;: {
                    &#39;format&#39;: &#39;&lt;h&#39;,
                    &#39;start_byte&#39;: 28,
                    &#39;value&#39;: 0x00
                },
                &#39;comm_failure&#39;: {
                    &#39;format&#39;: &#39;&lt;B&#39;,
                    &#39;start_byte&#39;: 30,
                    &#39;value&#39;: 0
                },
                &#39;schedule&#39;: {
                    # Stored as wchar_t[200]. Each wchar_t is 2 bytes, twice as big as standard char in Python
                    &#39;format&#39;: &#39;400s&#39;,
                    &#39;start_byte&#39;: 31,
                    &#39;value&#39;: &#39;fake_schedule&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;testname&#39;: {
                    # Stored as wchar_t[72]
                    &#39;format&#39;: &#39;144s&#39;,
                    &#39;start_byte&#39;: 431,
                    &#39;value&#39;: &#39;fake_testname&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;exit_condition&#39;: {
                    &#39;format&#39;: &#39;100s&#39;,
                    &#39;start_byte&#39;: 575,
                    &#39;value&#39;: &#39;none&#39;,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
                &#39;step_and_cycle_format&#39;: {
                    &#39;format&#39;: &#39;64s&#39;,
                    &#39;start_byte&#39;: 675,
                    &#39;value&#39;: &#39;none&#39;,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
                # Stored as wchar_t[72]
                &#39;barcode&#39;: {
                    &#39;format&#39;: &#39;144s&#39;,
                    &#39;start_byte&#39;: 739,
                    &#39;value&#39;: &#39;none&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16&#39;,
                },
                # Stored as wchar_t[72]
                &#39;can_config_name&#39;: {
                    &#39;format&#39;: &#39;400s&#39;,
                    &#39;start_byte&#39;: 883,
                    &#39;value&#39;: &#39;none&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16&#39;,
                },
                # Stored as wchar_t[72]
                &#39;smb_config_name&#39;: {
                    &#39;format&#39;: &#39;400s&#39;,
                    &#39;start_byte&#39;: 1283,
                    &#39;value&#39;: &#39;none&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16&#39;,
                },
                &#39;master_channel&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1683,
                    &#39;value&#39;: 0,
                },
                &#39;test_time_s&#39;: {
                    &#39;format&#39;: &#39;&lt;d&#39;,
                    &#39;start_byte&#39;: 1685,
                    &#39;value&#39;: 0,
                },
                &#39;step_time_s&#39;: {
                    &#39;format&#39;: &#39;&lt;d&#39;,
                    &#39;start_byte&#39;: 1693,
                    &#39;value&#39;: 0,
                },
                &#39;voltage_v&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1701,
                    &#39;value&#39;: 0,
                },
                &#39;current_a&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1705,
                    &#39;value&#39;: 0,
                },
                &#39;power_w&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1709,
                    &#39;value&#39;: 0,
                },
                &#39;charge_capacity_ah&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1713,
                    &#39;value&#39;: 0,
                },
                &#39;discharge_capacity_ah&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1717,
                    &#39;value&#39;: 0,
                },
                &#39;charge_energy_wh&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1721,
                    &#39;value&#39;: 0,
                },
                &#39;discharge_energy_wh&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1725,
                    &#39;value&#39;: 0,
                },
                &#39;internal_resistance_ohm&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1729,
                    &#39;value&#39;: 0,
                },
                &#39;dvdt_vbys&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1733,
                    &#39;value&#39;: 0,
                },
                &#39;acr_ohm&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1737,
                    &#39;value&#39;: 0,
                },
                &#39;aci_ohm&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1741,
                    &#39;value&#39;: 0,
                },
                &#39;aci_phase_degrees&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 1745,
                    &#39;value&#39;: 0,
                },
                &#39;aux_voltage_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1749,
                    &#39;value&#39;: 0,
                },
                &#39;aux_temperature_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1751,
                    &#39;value&#39;: 0,
                },
                &#39;aux_pressure_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1753,
                    &#39;value&#39;: 0,
                },
                &#39;aux_external_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1755,
                    &#39;value&#39;: 0,
                },
                &#39;aux_flow_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1757,
                    &#39;value&#39;: 0,
                },
                &#39;aux_ao_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1759,
                    &#39;value&#39;: 0,
                },
                &#39;aux_di_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1761,
                    &#39;value&#39;: 0,
                },
                &#39;aux_do_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1763,
                    &#39;value&#39;: 0,
                },
                &#39;aux_humidity_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1765,
                    &#39;value&#39;: 0,
                },
                &#39;aux_safety_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1767,
                    &#39;value&#39;: 0,
                },
                &#39;aux_ph_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1769,
                    &#39;value&#39;: 0,
                },
                &#39;aux_density_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1771,
                    &#39;value&#39;: 0,
                },
                &#39;bms_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1773,
                    &#39;value&#39;: 0,
                },
                &#39;smb_count&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 1775,
                    &#39;value&#39;: 0,
                },
            }

            # List of staus codes. Each index in the corresponding status code.
            status_code_dict = {
                0: &#39;Idle&#39;,
                1: &#39;Transition&#39;,
                2: &#39;Charge&#39;,
                3: &#39;Disharge&#39;,
                4: &#39;Rest&#39;,
                5: &#39;Wait&#39;,
                6: &#39;External Charge&#39;,
                7: &#39;Calibration&#39;,
                8: &#39;Unsafe&#39;,
                9: &#39;Pulse&#39;,
                10: &#39;Internal Resistance&#39;,
                11: &#39;AC Impedance&#39;,
                12: &#39;ACI Cell&#39;,
                13: &#39;Test Settings&#39;,
                14: &#39;Error&#39;,
                15: &#39;Finished&#39;,
                16: &#39;Volt Meter&#39;,
                17: &#39;Waiting for ACS&#39;,
                18: &#39;Pause&#39;,
                19: &#39;Empty&#39;,
                20: &#39;Idle from MCU&#39;,
                21: &#39;Start&#39;,
                22: &#39;Running&#39;,
                23: &#39;Step Transfer&#39;,
                24: &#39;Resume&#39;,
                25: &#39;Go Pause&#39;,
                26: &#39;Go Stop&#39;,
                27: &#39;Go Next Step&#39;,
                28: &#39;Online Update&#39;,
                29: &#39;DAQ Memory Unsafe&#39;,
                30: &#39;ACR&#39;
            }

            @classmethod
            def unpack(cls, msg_bin: bytearray) -&gt; dict:
                &#34;&#34;&#34;
                Same as the parent method, but uses aux counts to unpack aux readings

                Parameters
                ----------
                msg_bin : bytearry
                    The message to unpack.

                Returns
                -------
                msg_dict : dict
                    The message with items decoded into a dictionary
                &#34;&#34;&#34;
                msg_dict = super().unpack(msg_bin)
                msg_dict = cls.aux_readings_parser(
                    msg_dict, msg_bin, starting_aux_idx=1777)
                msg_dict[&#39;status&#39;] = cls.status_code_dict[msg_dict[&#39;status&#39;]]
                return msg_dict

            @classmethod
            def pack(cls, msg_values={}) -&gt; bytearray:
                &#34;&#34;&#34;
                Same as parent method, but handles packing aux measurements.

                Parameters
                ----------
                msg_values : dict
                    A dictionary detailing which default values in the message temple should be 
                    updated.

                Returns
                -------
                msg : bytearray
                    Packed response message.
                &#34;&#34;&#34;
                # TODO : Modify so that we can aux values can be packed.
                msg_bin = super().pack(msg_values)
                return msg_bin

            @classmethod
            def aux_readings_parser(cls, msg_dict: dict, msg_bin: bytearray, starting_aux_idx=1777):
                &#34;&#34;&#34;
                Parses the auxiliary readings in msg_bin based on the aux readings
                counts in msg_dict. Aux readings are then added as items to the msg_dict. 

                Parameters
                ----------
                msg_dict : dict
                    A dictionary containing the aux readings counts (aux_voltage_count, aux_voltage_count, etc)
                msg_bin : bytearray
                    The message to unpack as a byte array.
                starting_aux_idx : int
                    The starting index in the msg_bin for aux readings. 1777 in single channel messages

                Returns
                -------
                msg_dict : dict
                    The message with items decoded into a dictionary
                &#34;&#34;&#34;
                aux_lists = []

                aux_count_name_list = [
                    &#39;aux_voltage_count&#39;,
                    &#39;aux_temperature_count&#39;,
                    &#39;aux_pressure_count&#39;,
                    &#39;aux_external_count&#39;,
                    &#39;aux_flow_count&#39;,
                    &#39;aux_ao_count&#39;,
                    &#39;aux_di_count&#39;,
                    &#39;aux_do_count&#39;,
                    &#39;aux_humidity_count&#39;,
                    &#39;aux_safety_count&#39;,
                    &#39;aux_ph_count&#39;,
                    &#39;aux_density_count&#39;
                ]

                # Generate a list of readings for each aux reading.
                # If count is non-zero then genreate a aux_reading and aux_reading_dt list of that length
                # Else, generate empty lists for the aux_reading and aux_reading_dt
                for aux_count_name in aux_count_name_list:
                    aux_reading_name = re.split(&#39;_count&#39;, aux_count_name)[0]
                    aux_dt_name = aux_reading_name + &#39;_dt&#39;
                    if msg_dict[aux_count_name]:
                        msg_dict[aux_reading_name] = [0 for x in range(
                            msg_dict[aux_count_name])]
                        msg_dict[aux_dt_name] = [0 for x in range(
                            msg_dict[aux_count_name])]
                        aux_lists.append(
                            [msg_dict[aux_reading_name], msg_dict[aux_dt_name]])
                    else:
                        msg_dict[aux_reading_name] = []
                        msg_dict[aux_dt_name] = []

                # For aux readings that have a measurements, add them to the respective reading list.
                current_aux_idx = starting_aux_idx
                for readings_list in aux_lists:
                    for i in range(0, len(readings_list[0])):
                        # The first list in reading list is reading itself
                        readings_list[0][i] = struct.unpack(
                            &#39;&lt;f&#39;, msg_bin[current_aux_idx:current_aux_idx+4])[0]
                        # The second reading in the list is the dt value.
                        readings_list[1][i] = struct.unpack(
                            &#39;&lt;f&#39;, msg_bin[current_aux_idx+4:current_aux_idx+8])[0]
                        current_aux_idx += 8

                return msg_dict

    class AssignSchedule:
        &#39;&#39;&#39;
        Message for assiging a schedule to a specific channel. See
        THIRD_PARTY_ASSIGN_SCHEDULE/THIRD_PARTY_ASSIGN_SCHEDULE_FEEDBACK 
        in Arbin docs for more info.
        &#39;&#39;&#39;
        class Client(MessageABC):
            msg_length = 659
            command_code = 0xBB210001

            msg_specific_template = {
                &#39;channel&#39;: {
                    &#39;format&#39;: &#39;i&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;value&#39;: 0
                },
                # Always 0x00 for PyCTI since we only work with single channels
                &#39;assign_all_channels&#39;: {
                    &#39;format&#39;: &#39;1s&#39;,
                    &#39;start_byte&#39;: 24,
                    &#39;value&#39;: &#39;\0&#39;,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
                &#39;schedule&#39;: {
                    # Stored as wchar_t[200]. Each wchar_t is 2 bytes, twice as big as standard char in Python
                    &#39;format&#39;: &#39;400s&#39;,
                    &#39;start_byte&#39;: 25,
                    &#39;value&#39;: &#39;fake_schedule&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;test_capacity_ah&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 425,
                    &#39;value&#39;: 1.0,
                },
                &#39;barcode&#39;: {
                    &#39;format&#39;: &#39;144s&#39;,
                    &#39;start_byte&#39;: 429,
                    &#39;value&#39;: &#39;&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;user_variable_1&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 573,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_2&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 577,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_3&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 581,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_4&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 585,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_5&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 589,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_6&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 593,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_7&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 597,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_8&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 601,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_9&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 605,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_10&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 609,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_11&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 613,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_12&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 617,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_13&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 621,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_14&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 625,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_15&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 629,
                    &#39;value&#39;: 1.0,
                },
                &#39;user_variable_16&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 633,
                    &#39;value&#39;: 1.0,
                },
                &#39;reserved&#39;: {
                    &#39;format&#39;: &#39;32s&#39;,
                    &#39;start_byte&#39;: 637,
                    &#39;value&#39;: &#39;&#39;.join([&#39;\0&#39; for i in range(32)]),
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
            }

        class Server(MessageABC):
            msg_length = 128
            command_code = 0xBB120001

            msg_specific_template = {
                &#39;channel&#39;: {
                    &#39;format&#39;: &#39;i&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;value&#39;: 0
                },
                &#39;result&#39;: {
                    &#39;format&#39;: &#39;c&#39;,
                    &#39;start_byte&#39;: 24,
                    &#39;value&#39;: &#39;\0&#39;,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
                &#39;reserved&#39;: {
                    &#39;format&#39;: &#39;101s&#39;,
                    &#39;start_byte&#39;: 25,
                    &#39;value&#39;: &#39;&#39;.join([&#39;\0&#39; for i in range(101)]),
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
            }

            assign_schedule_feedback_codes = {
                0: &#39;success&#39;,
                16: &#39;channel does not exist&#39;,
                17: &#39;Monitor window in use at the moment&#39;,
                18: &#39;Schedule name cannot be empty&#39;,
                19: &#39;Schedule name not found&#39;,
                20: &#39;Channel is running&#39;,
                21: &#39;Channel is downloading another schedule currently&#39;,
                22: &#39;Cannot assign schedule when batch file is open&#39;,
                23: &#39;Assign failed&#39;,
                24: &#39;Not used: User should never see this&#39;,
            }

            @classmethod
            def unpack(cls, msg_bin: bytearray) -&gt; dict:
                &#34;&#34;&#34;
                Same as the parent method, but converts the result based on the
                assign_schedule_feedback_codes.

                Parameters
                ----------
                msg_bin : bytearray
                    The message to unpack.

                Returns
                -------
                msg_dict : dict
                    The message with items decoded into a dictionary
                &#34;&#34;&#34;
                msg_dict = super().unpack(msg_bin)
                msg_dict[&#39;result&#39;] = cls.assign_schedule_feedback_codes[
                    ord(msg_dict[&#39;result&#39;])]
                return msg_dict

    class StartSchedule:
        &#39;&#39;&#39;
        Message for assigning a schedule to a specific channel. See
        THIRD_PARTY_START_SCHEDULE/THIRD_PARTY_START_SCHEDULE_FEEDBACK 
        in Arbin docs for more info.
        &#39;&#39;&#39;
        class Client(MessageABC):
            msg_length = 160
            command_code = 0xBB320004

            msg_specific_template = {
                &#39;test_name&#39;: {
                    # Read as wchar_t which has length of 2 bytes each.
                    &#39;format&#39;: &#39;144s&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;value&#39;: &#39;pycti test name&#39;,
                    &#39;text_encoding&#39;: &#39;utf-16-le&#39;,
                },
                &#39;num_channels_to_start&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 164,
                    &#39;value&#39;: 1
                },
                &#39;channel&#39;: {
                    &#39;format&#39;: &#39;&lt;H&#39;,
                    &#39;start_byte&#39;: 168,
                    &#39;value&#39;: 0
                },
            }

        class Server(MessageABC):
            msg_length = 128
            command_code = 0XBB230004

            msg_specific_template = {
                &#39;channel&#39;: {
                    &#39;format&#39;: &#39;I&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;value&#39;: 0
                },
                &#39;result&#39;: {
                    &#39;format&#39;: &#39;c&#39;,
                    &#39;start_byte&#39;: 24,
                    &#39;value&#39;: &#39;\0&#39;,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
                &#39;reserved&#39;: {
                    &#39;format&#39;: &#39;101s&#39;,
                    &#39;start_byte&#39;: 25,
                    &#39;value&#39;: &#39;&#39;.join([&#39;\0&#39; for i in range(101)]),
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
            }

            start_test_feedback_codes = {
                0: &#39;success&#39;,
                16: &#39;Invalid channel index&#39;,
                17: &#39;There is a user controlling the monitor window (Start/Resume channel window is open)&#39;,
                18: &#39;Requested channel is running or unsafe&#39;,
                19: &#39;Channel not connected to DAQ&#39;,
                20: &#39;Schedule not compatible with current system configuration&#39;,
                21: &#39;No schedule assigned to channel&#39;,
                22: &#39;Schedule version does not match current version of MITS&#39;,
                23: &#39;Not used: User should never see this&#39;,
                24: &#39;Not used: User should never see this&#39;,
                25: &#39;Invalid step number&#39;,
                26: &#39;Not used: User should never see this&#39;,
                27: &#39;Invalid auxiliary count in schedule&#39;,
                28: &#39;Invalid build in auxiliary count&#39;,
                29: &#39;Not used: User should never see this&#39;,
                30: &#39;Check Aux Test Setting tab&#39;,
                31: &#39;No selected channels&#39;,
                32: &#39;Not used: User should never see this&#39;,
                33: &#39;DAQ still downloading schedule&#39;,
                34: &#39;Error querying database (database connection closed most likely)&#39;,
                35: &#39;Testname cannot be empty&#39;,
                36: &#39;Invalid step number&#39;,
                37: &#39;Invalid parallel channel number&#39;,
                38: &#39;Schedule safety precheck failed&#39;,
                39: &#39;Not used: User should never see this&#39;,
                40: &#39;Battery simulation error&#39;,
            }

            @classmethod
            def unpack(cls, msg_bin: bytearray) -&gt; dict:
                &#34;&#34;&#34;
                Same as the parent method, but converts the result based on the
                start_test_feedback_codes.

                Parameters
                ----------
                msg_bin : bytearray
                    The message to unpack.

                Returns
                -------
                msg_dict : dict
                    The message with items decoded into a dictionary
                &#34;&#34;&#34;
                msg_dict = super().unpack(msg_bin)
                msg_dict[&#39;result&#39;] = cls.start_test_feedback_codes[
                    ord(msg_dict[&#39;result&#39;])]
                return msg_dict

    class StopSchedule:
        &#39;&#39;&#39;
        Message for stopping a test on a specific channel. See
        THIRD_PARTY_STOP_SCHEDULE/THIRD_PARTY_STOP_SCHEDULE_FEEDBACK 
        in Arbin docs for more info.
        &#39;&#39;&#39;
        class Client(MessageABC):
            msg_length = 116
            command_code = 0xBB310001

            msg_specific_template = {
                &#39;channel&#39;: {
                    &#39;format&#39;: &#39;I&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;value&#39;: 0
                },
                # Always 0x00, others all channels are stopped.
                &#39;stop_all_channels&#39;: {
                    &#39;format&#39;: &#39;1s&#39;,
                    &#39;start_byte&#39;: 24,
                    &#39;value&#39;: &#39;\0&#39;,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
                &#39;reserved&#39;: {
                    &#39;format&#39;: &#39;101s&#39;,
                    &#39;start_byte&#39;: 25,
                    &#39;value&#39;: &#39;&#39;.join([&#39;\0&#39; for i in range(101)]),
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
            }

        class Server(MessageABC):
            msg_length = 128
            command_code = 0XBB130001

            msg_specific_template = {
                &#39;channel&#39;: {
                    &#39;format&#39;: &#39;I&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;value&#39;: 0
                },
                &#39;result&#39;: {
                    &#39;format&#39;: &#39;c&#39;,
                    &#39;start_byte&#39;: 24,
                    &#39;value&#39;: &#39;\0&#39;,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
                &#39;reserved&#39;: {
                    &#39;format&#39;: &#39;101s&#39;,
                    &#39;start_byte&#39;: 25,
                    &#39;value&#39;: &#39;&#39;.join([&#39;\0&#39; for i in range(101)]),
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
            }

            stop_test_feedback_codes = {
                0: &#39;success&#39;,
                16: &#39;Channel index does not exist&#39;,
                17: &#39;Someone else is controlling monitor window at the moment&#39;,
                18: &#39;Not used: User should never see this&#39;,
                19: &#39;Not used: User should never see this&#39;,
            }

            @classmethod
            def unpack(cls, msg_bin: bytearray) -&gt; dict:
                &#34;&#34;&#34;
                Same as the parent method, but converts the result based on the
                stop_test_feedback_codes.

                Parameters
                ----------
                msg_bin : bytearray
                    The message to unpack.

                Returns
                -------
                msg_dict : dict
                    The message with items decoded into a dictionary
                &#34;&#34;&#34;
                msg_dict = super().unpack(msg_bin)
                msg_dict[&#39;result&#39;] = cls.stop_test_feedback_codes[
                    ord(msg_dict[&#39;result&#39;])]
                return msg_dict

    class SetMetaVariable:
        &#39;&#39;&#39;
        Message for setting meta variables. 
        THIRD_PARTY_SET_MV_VALUE/THIRD_PARTY_SET_MV_VALUE_FEEDBACK 
        in Arbin docs for more info.
        &#39;&#39;&#39;
        class Client(MessageABC):
            msg_length = 62
            command_code = 0xBB150001

            msg_specific_template = {
                &#39;channel&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;value&#39;: 0
                },
                # The only mv_type allowed for CTI is 1
                &#39;mv_type&#39;: {
                    &#39;format&#39;: &#39;&lt;i&#39;,
                    &#39;start_byte&#39;: 24,
                    &#39;value&#39;: 1
                },
                # This determines which meta variable is set. Defaults to MV 1.
                &#39;mv_meta_code&#39;: {
                    &#39;format&#39;: &#39;&lt;i&#39;,
                    &#39;start_byte&#39;: 28,
                    &#39;value&#39;: 52,
                },
                &#39;reserved_1&#39;: {
                    &#39;format&#39;: &#39;16s&#39;,
                    &#39;start_byte&#39;: 32,
                    &#39;value&#39;: &#39;&#39;.join([&#39;\0&#39; for i in range(16)]),
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
                # The only value type allowed for CTI is 1, float.
                &#39;mv_value_type&#39;: {
                    &#39;format&#39;: &#39;&lt;i&#39;,
                    &#39;start_byte&#39;: 48,
                    &#39;value&#39;: 1
                },
                &#39;mv_data&#39;: {
                    &#39;format&#39;: &#39;&lt;f&#39;,
                    &#39;start_byte&#39;: 52,
                    &#39;value&#39;: 1
                },
                &#39;reserved_2&#39;: {
                    &#39;format&#39;: &#39;16s&#39;,
                    &#39;start_byte&#39;: 56,
                    &#39;value&#39;: &#39;&#39;.join([&#39;\0&#39; for i in range(16)]),
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
            }

            # Specifies the code for each variable. E.g. MV_UD1 has a code of 52
            mv_channel_codes = {
                1: 52,
                2: 53,
                3: 54,
                4: 55,
                5: 105,
                6: 106,
                7: 107,
                8: 108,
                9: 109,
                10: 110,
                11: 111,
                12: 112,
                13: 113,
                14: 114,
                15: 115,
                16: 116,
            }

        class Server(MessageABC):
            msg_length = 128
            command_code = 0XBB510001

            msg_specific_template = {
                &#39;channel&#39;: {
                    &#39;format&#39;: &#39;&lt;I&#39;,
                    &#39;start_byte&#39;: 20,
                    &#39;value&#39;: 0
                },
                &#39;result&#39;: {
                    &#39;format&#39;: &#39;c&#39;,
                    &#39;start_byte&#39;: 24,
                    &#39;value&#39;: &#39;\0&#39;,
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
                &#39;reserved&#39;: {
                    &#39;format&#39;: &#39;101s&#39;,
                    &#39;start_byte&#39;: 25,
                    &#39;value&#39;: &#39;&#39;.join([&#39;\0&#39; for i in range(101)]),
                    &#39;text_encoding&#39;: &#39;utf-8&#39;,
                },
            }

            mv_result_decoder = {
                0: &#39;success&#39;,
                16: &#39;Set MV Failure&#39;,
                17: &#39;Channel is not running&#39;,
                18: &#39;Meta code does not exist&#39;
            }

            @classmethod
            def unpack(cls, msg_bin: bytearray) -&gt; dict:
                &#34;&#34;&#34;
                Same as the parent method, but converts the result based on the
                stop_test_feedback_codes.

                Parameters
                ----------
                msg_bin : bytearry
                    The message to unpack.

                Returns
                -------
                msg_dict : dict
                    The message with items decoded into a dictionary
                &#34;&#34;&#34;
                msg_dict = super().unpack(msg_bin)

                msg_dict[&#39;result&#39;] = cls.mv_result_decoder[
                    ord(msg_dict[&#39;result&#39;])]

                return msg_dict</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pycti.messages.Msg.AssignSchedule"><code class="name">var <span class="ident">AssignSchedule</span></code></dt>
<dd>
<div class="desc"><p>Message for assiging a schedule to a specific channel. See
THIRD_PARTY_ASSIGN_SCHEDULE/THIRD_PARTY_ASSIGN_SCHEDULE_FEEDBACK
in Arbin docs for more info.</p></div>
</dd>
<dt id="pycti.messages.Msg.ChannelInfo"><code class="name">var <span class="ident">ChannelInfo</span></code></dt>
<dd>
<div class="desc"><p>Message for getting channel info from cycler. See
CTI_REQUEST_GET_CHANNELS_INFO/CTI_REQUEST_GET_CHANNELS_INFO_FEED_BACK
in Arbin docs for more info.</p></div>
</dd>
<dt id="pycti.messages.Msg.Login"><code class="name">var <span class="ident">Login</span></code></dt>
<dd>
<div class="desc"><p>Message for logging into Arbin cycler. See
CTI_REQUEST_LOGIN/CTI_REQUEST_LOGIN_FEEDBACK
in Arbin docs for more info.</p></div>
</dd>
<dt id="pycti.messages.Msg.SetMetaVariable"><code class="name">var <span class="ident">SetMetaVariable</span></code></dt>
<dd>
<div class="desc"><p>Message for setting meta variables.
THIRD_PARTY_SET_MV_VALUE/THIRD_PARTY_SET_MV_VALUE_FEEDBACK
in Arbin docs for more info.</p></div>
</dd>
<dt id="pycti.messages.Msg.StartSchedule"><code class="name">var <span class="ident">StartSchedule</span></code></dt>
<dd>
<div class="desc"><p>Message for assigning a schedule to a specific channel. See
THIRD_PARTY_START_SCHEDULE/THIRD_PARTY_START_SCHEDULE_FEEDBACK
in Arbin docs for more info.</p></div>
</dd>
<dt id="pycti.messages.Msg.StopSchedule"><code class="name">var <span class="ident">StopSchedule</span></code></dt>
<dd>
<div class="desc"><p>Message for stopping a test on a specific channel. See
THIRD_PARTY_STOP_SCHEDULE/THIRD_PARTY_STOP_SCHEDULE_FEEDBACK
in Arbin docs for more info.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pycti" href="index.html">pycti</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pycti.messages.MessageABC" href="#pycti.messages.MessageABC">MessageABC</a></code></h4>
<ul class="">
<li><code><a title="pycti.messages.MessageABC.base_template" href="#pycti.messages.MessageABC.base_template">base_template</a></code></li>
<li><code><a title="pycti.messages.MessageABC.command_code" href="#pycti.messages.MessageABC.command_code">command_code</a></code></li>
<li><code><a title="pycti.messages.MessageABC.msg_length" href="#pycti.messages.MessageABC.msg_length">msg_length</a></code></li>
<li><code><a title="pycti.messages.MessageABC.msg_specific_template" href="#pycti.messages.MessageABC.msg_specific_template">msg_specific_template</a></code></li>
<li><code><a title="pycti.messages.MessageABC.pack" href="#pycti.messages.MessageABC.pack">pack</a></code></li>
<li><code><a title="pycti.messages.MessageABC.unpack" href="#pycti.messages.MessageABC.unpack">unpack</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.messages.Msg" href="#pycti.messages.Msg">Msg</a></code></h4>
<ul class="two-column">
<li><code><a title="pycti.messages.Msg.AssignSchedule" href="#pycti.messages.Msg.AssignSchedule">AssignSchedule</a></code></li>
<li><code><a title="pycti.messages.Msg.ChannelInfo" href="#pycti.messages.Msg.ChannelInfo">ChannelInfo</a></code></li>
<li><code><a title="pycti.messages.Msg.Login" href="#pycti.messages.Msg.Login">Login</a></code></li>
<li><code><a title="pycti.messages.Msg.SetMetaVariable" href="#pycti.messages.Msg.SetMetaVariable">SetMetaVariable</a></code></li>
<li><code><a title="pycti.messages.Msg.StartSchedule" href="#pycti.messages.Msg.StartSchedule">StartSchedule</a></code></li>
<li><code><a title="pycti.messages.Msg.StopSchedule" href="#pycti.messages.Msg.StopSchedule">StopSchedule</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>