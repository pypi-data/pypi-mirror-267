# (generated with --quick)

import light_database.sql
from typing import Any, Dict, Iterable, Optional, Type, Union, Tuple, Callable
from pandas import DataFrame
from dbutils.pooled_db import PooledDedicatedDBConnection

def retry(func: Callable) -> Callable: ...

class BaseDB:
    _section: Tuple[str]
    @classmethod
    def _key_on_thread(cls) -> str: ...
    @staticmethod
    def _local_delattr(key: str) -> None: ...
    @staticmethod
    def _local_getattr(key: str) -> Any: ...
    @staticmethod
    def _local_hasattr(key: str) -> bool: ...
    @staticmethod
    def _local_setattr(key: str, value: Any) -> None: ...
    @classmethod
    def _read_config(cls, section: str) -> Dict[str, Union[int, str]]: ...
    @classmethod
    def new(cls, *section: str) -> Type[BaseDB]: ...

class RegularDB(BaseDB):
    _creator: None
    @classmethod
    def _reset(cls, section: str) -> None: ...
    @classmethod
    def connection(cls) -> PooledDedicatedDBConnection: ...
    @classmethod
    def delete(cls, table: str) -> light_database.sql.DeleteSqlModel: ...
    @classmethod
    def description(cls, table: str) -> DataFrame: ...
    @classmethod
    def execute(cls, sql: str, values: Iterable = ()) -> None: ...
    @classmethod
    def filter(cls, table: str) -> light_database.sql.FilterSqlModel: ...
    @classmethod
    def insert(cls, table: str) -> light_database.sql.InsertSqlModel: ...
    @classmethod
    def query(cls, sql: str, values: Iterable = ()) -> DataFrame: ...
    @classmethod
    def tables(cls, db: Optional[str] = None) -> DataFrame: ...
    @classmethod
    def update(cls, table: str) -> light_database.sql.UpdateSqlModel: ...
