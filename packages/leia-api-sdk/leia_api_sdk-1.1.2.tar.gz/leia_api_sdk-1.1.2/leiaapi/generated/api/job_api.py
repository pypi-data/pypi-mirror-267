# coding: utf-8

"""
    LEIA RESTful API for AI

    Leia API  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Contact: contact@leia.io
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from datetime import datetime

from pydantic import Field, StrictBool, StrictInt, StrictStr

from typing import Dict, List, Optional

from leiaapi.generated.models.conditional_body import ConditionalBody
from leiaapi.generated.models.job import Job
from leiaapi.generated.models.job_types import JobTypes
from leiaapi.generated.models.statuses import Statuses

from leiaapi.generated.api_client import ApiClient
from leiaapi.generated.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class JobApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def cancel_job(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], job_id : Annotated[StrictStr, Field(..., description="The id of the job to delete")], **kwargs) -> None:  # noqa: E501
        """Cancels a job in Leia API  # noqa: E501

        Cancels a job in Leia API (This will not really delete it, just mark it as cancelled, so dependent jobs will fail)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cancel_job(token, job_id, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param job_id: The id of the job to delete (required)
        :type job_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.cancel_job_with_http_info(token, job_id, **kwargs)  # noqa: E501

    @validate_arguments
    def cancel_job_with_http_info(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], job_id : Annotated[StrictStr, Field(..., description="The id of the job to delete")], **kwargs):  # noqa: E501
        """Cancels a job in Leia API  # noqa: E501

        Cancels a job in Leia API (This will not really delete it, just mark it as cancelled, so dependent jobs will fail)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cancel_job_with_http_info(token, job_id, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param job_id: The id of the job to delete (required)
        :type job_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'token',
            'job_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_job" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['job_id']:
            _path_params['job_id'] = _params['job_id']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['token']:
            _header_params['token'] = _params['token']

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/job/{job_id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def create_conditional_job(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], execute_after_id : Annotated[StrictStr, Field(..., description="The id of a job that must be in PROCESSED status before this one can be started (used to chain jobs even before the first ones are terminated). If the referenced job becomes FAILED or is CANCELED, this one will fail")], callback_url : Annotated[Optional[StrictStr], Field(description="Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.")] = None, block_processing : Annotated[Optional[StrictBool], Field(description="If true, blocks processing on the job until /job/{id}/start is called. Default is false")] = None, conditional_body : Annotated[Optional[ConditionalBody], Field(description="Contains the rules to choose the model to apply. All the previous query parameters can also be passed as JSON in the body of the request")] = None, **kwargs) -> Job:  # noqa: E501
        """Asynchronously and conditionaly applies model(s) on documents  # noqa: E501

        Asynchronously runs one or more list of jobs on accessible documents and returns a Job.<br /> The list of jobs to run and the documents on which they should be run will be chosen depending on the rules parameter that is set in the body of the request and the result of the execute_after_id job.<br /> Rules should be a map[string,object] where the key is a user chosen id and the value is a list of objects containing the same parameters as normal calls to /model/{model_id}/apply{document_ids} or /document/{document_ids}/transform/{output_type} and a conditions field.<br /> If all the field/values in the conditions of a rule are contained as is in the result of the execute_after_id job, then the list of jobs will be executed in order with the given parameters, each job depending on the previous one in the list, else it won't be executed at all<br /> Syntax for conditions is as follows:   * \"field_name\" : value In which case the field field_name must be equal to the value for the job to be executed. value can be any valid json type (int, float, string...)   * \"field_name\": {\"operator\" : value} Where operator is a [Mongo like comparison operator](https://docs.mongodb.com/manual/reference/operator/query-comparison/). In this case the comparison between field field_name's value must be true for the job to be executed. value can be any valid json type (int, float, string...)   * \"field_name\": [{\"operator_1\" : value_1}...{\"operator_n\" : value_n}] Where operator_i is a [Mongo like comparison operator](https://docs.mongodb.com/manual/reference/operator/query-comparison/). In this case the comparison between field field_name's value must be true for all items in the list for the job to be executed. value_i can be any valid json type (int, float, string...). {\"$eq\" : value_i} can be abbreviated as value_i in the list.  You can keep the document_ids field of any job empty apart for the first job of a rule. If it is, the job will use the results of previous job's as an input if no tag is set, or the document_ids of the execute_after_id job + tag if tag is set.<br /> If the conditions are not mutually exclusive, 2 or more models may be executed.<br /> The result will be sent back as a map of results where the key is the rule id, and containing one entry for list of jobs that was executed. This entry will contain all the results of the executed jobs, in execution order<br /> This is mostly but not necessarily meant to be used after a classifier model, so that an execution path can be chosen automatically depending on the result of the classification.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_conditional_job(token, execute_after_id, callback_url, block_processing, conditional_body, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param execute_after_id: The id of a job that must be in PROCESSED status before this one can be started (used to chain jobs even before the first ones are terminated). If the referenced job becomes FAILED or is CANCELED, this one will fail (required)
        :type execute_after_id: str
        :param callback_url: Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.
        :type callback_url: str
        :param block_processing: If true, blocks processing on the job until /job/{id}/start is called. Default is false
        :type block_processing: bool
        :param conditional_body: Contains the rules to choose the model to apply. All the previous query parameters can also be passed as JSON in the body of the request
        :type conditional_body: ConditionalBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Job
        """
        kwargs['_return_http_data_only'] = True
        return self.create_conditional_job_with_http_info(token, execute_after_id, callback_url, block_processing, conditional_body, **kwargs)  # noqa: E501

    @validate_arguments
    def create_conditional_job_with_http_info(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], execute_after_id : Annotated[StrictStr, Field(..., description="The id of a job that must be in PROCESSED status before this one can be started (used to chain jobs even before the first ones are terminated). If the referenced job becomes FAILED or is CANCELED, this one will fail")], callback_url : Annotated[Optional[StrictStr], Field(description="Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.")] = None, block_processing : Annotated[Optional[StrictBool], Field(description="If true, blocks processing on the job until /job/{id}/start is called. Default is false")] = None, conditional_body : Annotated[Optional[ConditionalBody], Field(description="Contains the rules to choose the model to apply. All the previous query parameters can also be passed as JSON in the body of the request")] = None, **kwargs):  # noqa: E501
        """Asynchronously and conditionaly applies model(s) on documents  # noqa: E501

        Asynchronously runs one or more list of jobs on accessible documents and returns a Job.<br /> The list of jobs to run and the documents on which they should be run will be chosen depending on the rules parameter that is set in the body of the request and the result of the execute_after_id job.<br /> Rules should be a map[string,object] where the key is a user chosen id and the value is a list of objects containing the same parameters as normal calls to /model/{model_id}/apply{document_ids} or /document/{document_ids}/transform/{output_type} and a conditions field.<br /> If all the field/values in the conditions of a rule are contained as is in the result of the execute_after_id job, then the list of jobs will be executed in order with the given parameters, each job depending on the previous one in the list, else it won't be executed at all<br /> Syntax for conditions is as follows:   * \"field_name\" : value In which case the field field_name must be equal to the value for the job to be executed. value can be any valid json type (int, float, string...)   * \"field_name\": {\"operator\" : value} Where operator is a [Mongo like comparison operator](https://docs.mongodb.com/manual/reference/operator/query-comparison/). In this case the comparison between field field_name's value must be true for the job to be executed. value can be any valid json type (int, float, string...)   * \"field_name\": [{\"operator_1\" : value_1}...{\"operator_n\" : value_n}] Where operator_i is a [Mongo like comparison operator](https://docs.mongodb.com/manual/reference/operator/query-comparison/). In this case the comparison between field field_name's value must be true for all items in the list for the job to be executed. value_i can be any valid json type (int, float, string...). {\"$eq\" : value_i} can be abbreviated as value_i in the list.  You can keep the document_ids field of any job empty apart for the first job of a rule. If it is, the job will use the results of previous job's as an input if no tag is set, or the document_ids of the execute_after_id job + tag if tag is set.<br /> If the conditions are not mutually exclusive, 2 or more models may be executed.<br /> The result will be sent back as a map of results where the key is the rule id, and containing one entry for list of jobs that was executed. This entry will contain all the results of the executed jobs, in execution order<br /> This is mostly but not necessarily meant to be used after a classifier model, so that an execution path can be chosen automatically depending on the result of the classification.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_conditional_job_with_http_info(token, execute_after_id, callback_url, block_processing, conditional_body, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param execute_after_id: The id of a job that must be in PROCESSED status before this one can be started (used to chain jobs even before the first ones are terminated). If the referenced job becomes FAILED or is CANCELED, this one will fail (required)
        :type execute_after_id: str
        :param callback_url: Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.
        :type callback_url: str
        :param block_processing: If true, blocks processing on the job until /job/{id}/start is called. Default is false
        :type block_processing: bool
        :param conditional_body: Contains the rules to choose the model to apply. All the previous query parameters can also be passed as JSON in the body of the request
        :type conditional_body: ConditionalBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Job, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'token',
            'execute_after_id',
            'callback_url',
            'block_processing',
            'conditional_body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_conditional_job" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['execute_after_id']:
            _path_params['execute_after_id'] = _params['execute_after_id']

        # process the query parameters
        _query_params = []
        if _params.get('callback_url') is not None:  # noqa: E501
            _query_params.append(('callback_url', _params['callback_url']))
        if _params.get('block_processing') is not None:  # noqa: E501
            _query_params.append(('block_processing', _params['block_processing']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['token']:
            _header_params['token'] = _params['token']

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params['conditional_body']:
            _body_params = _params['conditional_body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Job",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/job/conditional/{execute_after_id}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_job(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], job_id : Annotated[StrictStr, Field(..., description="The id of the job to retrieve")], **kwargs) -> Job:  # noqa: E501
        """Retrieves a job from Leia API  # noqa: E501

        Retrieves a job from Leia API   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_job(token, job_id, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param job_id: The id of the job to retrieve (required)
        :type job_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Job
        """
        kwargs['_return_http_data_only'] = True
        return self.get_job_with_http_info(token, job_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_job_with_http_info(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], job_id : Annotated[StrictStr, Field(..., description="The id of the job to retrieve")], **kwargs):  # noqa: E501
        """Retrieves a job from Leia API  # noqa: E501

        Retrieves a job from Leia API   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_job_with_http_info(token, job_id, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param job_id: The id of the job to retrieve (required)
        :type job_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Job, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'token',
            'job_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['job_id']:
            _path_params['job_id'] = _params['job_id']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['token']:
            _header_params['token'] = _params['token']

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Job",
            '401': None,
            '403': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/job/{job_id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_job_statuses(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], job_ids : Annotated[List[StrictStr], Field(..., description="The ids of the jobs to retrieve, comma separated")], **kwargs) -> Dict[str, Statuses]:  # noqa: E501
        """Retrieves job statuses from Leia API  # noqa: E501

        Retrieves a list of job statuses from Leia API   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_job_statuses(token, job_ids, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param job_ids: The ids of the jobs to retrieve, comma separated (required)
        :type job_ids: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Dict[str, Statuses]
        """
        kwargs['_return_http_data_only'] = True
        return self.get_job_statuses_with_http_info(token, job_ids, **kwargs)  # noqa: E501

    @validate_arguments
    def get_job_statuses_with_http_info(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], job_ids : Annotated[List[StrictStr], Field(..., description="The ids of the jobs to retrieve, comma separated")], **kwargs):  # noqa: E501
        """Retrieves job statuses from Leia API  # noqa: E501

        Retrieves a list of job statuses from Leia API   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_job_statuses_with_http_info(token, job_ids, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param job_ids: The ids of the jobs to retrieve, comma separated (required)
        :type job_ids: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Dict[str, Statuses], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'token',
            'job_ids'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_statuses" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['job_ids']:
            _path_params['job_ids'] = _params['job_ids']
            _collection_formats['job_ids'] = 'csv'

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['token']:
            _header_params['token'] = _params['token']

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Dict[str, Statuses]",
            '401': None,
            '403': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/job/{job_ids}/status', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_jobs(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], job_id : Annotated[Optional[StrictStr], Field(description="The id of the job")] = None, application_id : Annotated[Optional[StrictStr], Field(description="The id of the owner of the documents processed by this job")] = None, job_type : Annotated[Optional[JobTypes], Field(description="The type of the job (predict, pdf-images, image-text or transform)")] = None, model_id : Annotated[Optional[StrictStr], Field(description="The model used by the job (only for predict jobs)")] = None, document_id : Annotated[Optional[StrictStr], Field(description="The document that this the job is processing")] = None, execute_after_id : Annotated[Optional[StrictStr], Field(description="The job that is a prerequisite for this job to run")] = None, parent_job_id : Annotated[Optional[StrictStr], Field(description="The job that is the parent of this job")] = None, status : Annotated[Optional[Statuses], Field(description="The status of the job")] = None, created_after : Annotated[Optional[datetime], Field(description="If specified, keeps only jobs created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)")] = None, created_before : Annotated[Optional[datetime], Field(description="If specified, keeps only jobs created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)")] = None, sort : Annotated[Optional[StrictStr], Field(description="If specified, sorts the jobs by a list of existing parameters separated by commas. Can be 'submitter_id', 'application_id', 'creation_time', 'starting_time', 'finished_time', 'job_type', 'model_id', 'document_ids', 'status', 'parent_job_id'. Sorts in ascending order by default. If a parameter is preceded by '-', it is sorted in descending order.")] = None, offset : Annotated[Optional[StrictInt], Field(description="Number of the first job to send (pagination)")] = None, limit : Annotated[Optional[StrictInt], Field(description="Maximum number of jobs to send (pagination)")] = None, **kwargs) -> List[Job]:  # noqa: E501
        """Retrieves jobs (paginated)  # noqa: E501

        Get jobs from the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_jobs(token, job_id, application_id, job_type, model_id, document_id, execute_after_id, parent_job_id, status, created_after, created_before, sort, offset, limit, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param job_id: The id of the job
        :type job_id: str
        :param application_id: The id of the owner of the documents processed by this job
        :type application_id: str
        :param job_type: The type of the job (predict, pdf-images, image-text or transform)
        :type job_type: JobTypes
        :param model_id: The model used by the job (only for predict jobs)
        :type model_id: str
        :param document_id: The document that this the job is processing
        :type document_id: str
        :param execute_after_id: The job that is a prerequisite for this job to run
        :type execute_after_id: str
        :param parent_job_id: The job that is the parent of this job
        :type parent_job_id: str
        :param status: The status of the job
        :type status: Statuses
        :param created_after: If specified, keeps only jobs created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :type created_after: datetime
        :param created_before: If specified, keeps only jobs created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :type created_before: datetime
        :param sort: If specified, sorts the jobs by a list of existing parameters separated by commas. Can be 'submitter_id', 'application_id', 'creation_time', 'starting_time', 'finished_time', 'job_type', 'model_id', 'document_ids', 'status', 'parent_job_id'. Sorts in ascending order by default. If a parameter is preceded by '-', it is sorted in descending order.
        :type sort: str
        :param offset: Number of the first job to send (pagination)
        :type offset: int
        :param limit: Maximum number of jobs to send (pagination)
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Job]
        """
        kwargs['_return_http_data_only'] = True
        return self.get_jobs_with_http_info(token, job_id, application_id, job_type, model_id, document_id, execute_after_id, parent_job_id, status, created_after, created_before, sort, offset, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def get_jobs_with_http_info(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], job_id : Annotated[Optional[StrictStr], Field(description="The id of the job")] = None, application_id : Annotated[Optional[StrictStr], Field(description="The id of the owner of the documents processed by this job")] = None, job_type : Annotated[Optional[JobTypes], Field(description="The type of the job (predict, pdf-images, image-text or transform)")] = None, model_id : Annotated[Optional[StrictStr], Field(description="The model used by the job (only for predict jobs)")] = None, document_id : Annotated[Optional[StrictStr], Field(description="The document that this the job is processing")] = None, execute_after_id : Annotated[Optional[StrictStr], Field(description="The job that is a prerequisite for this job to run")] = None, parent_job_id : Annotated[Optional[StrictStr], Field(description="The job that is the parent of this job")] = None, status : Annotated[Optional[Statuses], Field(description="The status of the job")] = None, created_after : Annotated[Optional[datetime], Field(description="If specified, keeps only jobs created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)")] = None, created_before : Annotated[Optional[datetime], Field(description="If specified, keeps only jobs created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)")] = None, sort : Annotated[Optional[StrictStr], Field(description="If specified, sorts the jobs by a list of existing parameters separated by commas. Can be 'submitter_id', 'application_id', 'creation_time', 'starting_time', 'finished_time', 'job_type', 'model_id', 'document_ids', 'status', 'parent_job_id'. Sorts in ascending order by default. If a parameter is preceded by '-', it is sorted in descending order.")] = None, offset : Annotated[Optional[StrictInt], Field(description="Number of the first job to send (pagination)")] = None, limit : Annotated[Optional[StrictInt], Field(description="Maximum number of jobs to send (pagination)")] = None, **kwargs):  # noqa: E501
        """Retrieves jobs (paginated)  # noqa: E501

        Get jobs from the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_jobs_with_http_info(token, job_id, application_id, job_type, model_id, document_id, execute_after_id, parent_job_id, status, created_after, created_before, sort, offset, limit, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param job_id: The id of the job
        :type job_id: str
        :param application_id: The id of the owner of the documents processed by this job
        :type application_id: str
        :param job_type: The type of the job (predict, pdf-images, image-text or transform)
        :type job_type: JobTypes
        :param model_id: The model used by the job (only for predict jobs)
        :type model_id: str
        :param document_id: The document that this the job is processing
        :type document_id: str
        :param execute_after_id: The job that is a prerequisite for this job to run
        :type execute_after_id: str
        :param parent_job_id: The job that is the parent of this job
        :type parent_job_id: str
        :param status: The status of the job
        :type status: Statuses
        :param created_after: If specified, keeps only jobs created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :type created_after: datetime
        :param created_before: If specified, keeps only jobs created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :type created_before: datetime
        :param sort: If specified, sorts the jobs by a list of existing parameters separated by commas. Can be 'submitter_id', 'application_id', 'creation_time', 'starting_time', 'finished_time', 'job_type', 'model_id', 'document_ids', 'status', 'parent_job_id'. Sorts in ascending order by default. If a parameter is preceded by '-', it is sorted in descending order.
        :type sort: str
        :param offset: Number of the first job to send (pagination)
        :type offset: int
        :param limit: Maximum number of jobs to send (pagination)
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Job], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'token',
            'job_id',
            'application_id',
            'job_type',
            'model_id',
            'document_id',
            'execute_after_id',
            'parent_job_id',
            'status',
            'created_after',
            'created_before',
            'sort',
            'offset',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_jobs" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('job_id') is not None:  # noqa: E501
            _query_params.append(('job_id', _params['job_id']))
        if _params.get('application_id') is not None:  # noqa: E501
            _query_params.append(('application_id', _params['application_id']))
        if _params.get('job_type') is not None:  # noqa: E501
            _query_params.append(('job_type', _params['job_type']))
        if _params.get('model_id') is not None:  # noqa: E501
            _query_params.append(('model_id', _params['model_id']))
        if _params.get('document_id') is not None:  # noqa: E501
            _query_params.append(('document_id', _params['document_id']))
        if _params.get('execute_after_id') is not None:  # noqa: E501
            _query_params.append(('execute_after_id', _params['execute_after_id']))
        if _params.get('parent_job_id') is not None:  # noqa: E501
            _query_params.append(('parent_job_id', _params['parent_job_id']))
        if _params.get('status') is not None:  # noqa: E501
            _query_params.append(('status', _params['status']))
        if _params.get('created_after') is not None:  # noqa: E501
            _query_params.append(('created_after', _params['created_after']))
        if _params.get('created_before') is not None:  # noqa: E501
            _query_params.append(('created_before', _params['created_before']))
        if _params.get('sort') is not None:  # noqa: E501
            _query_params.append(('sort', _params['sort']))
        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))
        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['token']:
            _header_params['token'] = _params['token']

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[Job]",
            '401': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/job', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def start_job(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], job_id : Annotated[StrictStr, Field(..., description="The id of the job to start")], **kwargs) -> Job:  # noqa: E501
        """Starts a job in BLOCKED status within Leia API  # noqa: E501

        Triggers a job in BLOCKED status   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.start_job(token, job_id, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param job_id: The id of the job to start (required)
        :type job_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Job
        """
        kwargs['_return_http_data_only'] = True
        return self.start_job_with_http_info(token, job_id, **kwargs)  # noqa: E501

    @validate_arguments
    def start_job_with_http_info(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], job_id : Annotated[StrictStr, Field(..., description="The id of the job to start")], **kwargs):  # noqa: E501
        """Starts a job in BLOCKED status within Leia API  # noqa: E501

        Triggers a job in BLOCKED status   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.start_job_with_http_info(token, job_id, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param job_id: The id of the job to start (required)
        :type job_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Job, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'token',
            'job_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_job" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['job_id']:
            _path_params['job_id'] = _params['job_id']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['token']:
            _header_params['token'] = _params['token']

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Job",
            '401': None,
            '403': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/job/{job_id}/start', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
