# coding: utf-8

"""
    LEIA RESTful API for AI

    Leia API  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Contact: contact@leia.io
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from datetime import datetime

from pydantic import Field, StrictBool, StrictInt, StrictStr

from typing import Dict, List, Optional

from leiaapi.generated.models.document import Document
from leiaapi.generated.models.job import Job
from leiaapi.generated.models.transform_body import TransformBody
from leiaapi.generated.models.transform_types import TransformTypes

from leiaapi.generated.api_client import ApiClient
from leiaapi.generated.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class DocumentAdminApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def admin_create_document(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], application_id : Annotated[StrictStr, Field(..., description="The application that will own the model")], filename : Annotated[StrictStr, Field(..., description="The name of the file (if present, extension will be separated from filename in metadata of the document)")], body : StrictStr, ttl : Annotated[Optional[StrictInt], Field(description="The TTL (in seconds, not less than 60) for the document (if present, the document and any sub documents, annotations, or jobs linked to it will be deleted after the TTL is expired)")] = None, tags : Annotated[Optional[List[StrictStr]], Field(description="The tags of the document")] = None, **kwargs) -> Document:  # noqa: E501
        """Uploads a document to the Leia API (admin only)  # noqa: E501

        Uploads a document to Leia API for future use. This method is only accessible to admins   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_create_document(token, application_id, filename, body, ttl, tags, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param application_id: The application that will own the model (required)
        :type application_id: str
        :param filename: The name of the file (if present, extension will be separated from filename in metadata of the document) (required)
        :type filename: str
        :param body: (required)
        :type body: str
        :param ttl: The TTL (in seconds, not less than 60) for the document (if present, the document and any sub documents, annotations, or jobs linked to it will be deleted after the TTL is expired)
        :type ttl: int
        :param tags: The tags of the document
        :type tags: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Document
        """
        kwargs['_return_http_data_only'] = True
        return self.admin_create_document_with_http_info(token, application_id, filename, body, ttl, tags, **kwargs)  # noqa: E501

    @validate_arguments
    def admin_create_document_with_http_info(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], application_id : Annotated[StrictStr, Field(..., description="The application that will own the model")], filename : Annotated[StrictStr, Field(..., description="The name of the file (if present, extension will be separated from filename in metadata of the document)")], body : StrictStr, ttl : Annotated[Optional[StrictInt], Field(description="The TTL (in seconds, not less than 60) for the document (if present, the document and any sub documents, annotations, or jobs linked to it will be deleted after the TTL is expired)")] = None, tags : Annotated[Optional[List[StrictStr]], Field(description="The tags of the document")] = None, **kwargs):  # noqa: E501
        """Uploads a document to the Leia API (admin only)  # noqa: E501

        Uploads a document to Leia API for future use. This method is only accessible to admins   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_create_document_with_http_info(token, application_id, filename, body, ttl, tags, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param application_id: The application that will own the model (required)
        :type application_id: str
        :param filename: The name of the file (if present, extension will be separated from filename in metadata of the document) (required)
        :type filename: str
        :param body: (required)
        :type body: str
        :param ttl: The TTL (in seconds, not less than 60) for the document (if present, the document and any sub documents, annotations, or jobs linked to it will be deleted after the TTL is expired)
        :type ttl: int
        :param tags: The tags of the document
        :type tags: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Document, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'token',
            'application_id',
            'filename',
            'body',
            'ttl',
            'tags'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_create_document" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['application_id']:
            _path_params['application_id'] = _params['application_id']

        # process the query parameters
        _query_params = []
        if _params.get('filename') is not None:  # noqa: E501
            _query_params.append(('filename', _params['filename']))
        if _params.get('ttl') is not None:  # noqa: E501
            _query_params.append(('ttl', _params['ttl']))
        if _params.get('tags') is not None:  # noqa: E501
            _query_params.append(('tags', _params['tags']))
            _collection_formats['tags'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['token']:
            _header_params['token'] = _params['token']

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params['body']:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/octet-stream']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Document",
            '401': None,
        }

        return self.api_client.call_api(
            '/admin/{application_id}/document', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def admin_delete_document(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], application_id : Annotated[StrictStr, Field(..., description="The application to which the document to delete belongs")], document_id : Annotated[StrictStr, Field(..., description="The id of the document to delete")], **kwargs) -> None:  # noqa: E501
        """Deletes a document from Leia API (admin only)  # noqa: E501

        Deletes a document from Leia API. This method is only accessible to admins   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_delete_document(token, application_id, document_id, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param application_id: The application to which the document to delete belongs (required)
        :type application_id: str
        :param document_id: The id of the document to delete (required)
        :type document_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.admin_delete_document_with_http_info(token, application_id, document_id, **kwargs)  # noqa: E501

    @validate_arguments
    def admin_delete_document_with_http_info(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], application_id : Annotated[StrictStr, Field(..., description="The application to which the document to delete belongs")], document_id : Annotated[StrictStr, Field(..., description="The id of the document to delete")], **kwargs):  # noqa: E501
        """Deletes a document from Leia API (admin only)  # noqa: E501

        Deletes a document from Leia API. This method is only accessible to admins   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_delete_document_with_http_info(token, application_id, document_id, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param application_id: The application to which the document to delete belongs (required)
        :type application_id: str
        :param document_id: The id of the document to delete (required)
        :type document_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'token',
            'application_id',
            'document_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_delete_document" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['application_id']:
            _path_params['application_id'] = _params['application_id']
        if _params['document_id']:
            _path_params['document_id'] = _params['document_id']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['token']:
            _header_params['token'] = _params['token']

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/admin/{application_id}/document/{document_id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def admin_edit_document(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], application_id : Annotated[StrictStr, Field(..., description="The application to which the document to update belongs")], document_id : Annotated[StrictStr, Field(..., description="The id of the document to update")], filename : Annotated[Optional[StrictStr], Field(description="The new file name of the document")] = None, rotation_angle : Annotated[Optional[StrictInt], Field(description="The new rotation angle of the document")] = None, ttl : Annotated[Optional[StrictInt], Field(description="The TTL (in seconds, not less than 60) for the document (if present, the document and any sub documents, annotations, or jobs linked to it will be deleted after the TTL is expired)")] = None, **kwargs) -> Document:  # noqa: E501
        """Updates a document in Leia API (admin only)  # noqa: E501

        Updates metadata for a document. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_edit_document(token, application_id, document_id, filename, rotation_angle, ttl, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param application_id: The application to which the document to update belongs (required)
        :type application_id: str
        :param document_id: The id of the document to update (required)
        :type document_id: str
        :param filename: The new file name of the document
        :type filename: str
        :param rotation_angle: The new rotation angle of the document
        :type rotation_angle: int
        :param ttl: The TTL (in seconds, not less than 60) for the document (if present, the document and any sub documents, annotations, or jobs linked to it will be deleted after the TTL is expired)
        :type ttl: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Document
        """
        kwargs['_return_http_data_only'] = True
        return self.admin_edit_document_with_http_info(token, application_id, document_id, filename, rotation_angle, ttl, **kwargs)  # noqa: E501

    @validate_arguments
    def admin_edit_document_with_http_info(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], application_id : Annotated[StrictStr, Field(..., description="The application to which the document to update belongs")], document_id : Annotated[StrictStr, Field(..., description="The id of the document to update")], filename : Annotated[Optional[StrictStr], Field(description="The new file name of the document")] = None, rotation_angle : Annotated[Optional[StrictInt], Field(description="The new rotation angle of the document")] = None, ttl : Annotated[Optional[StrictInt], Field(description="The TTL (in seconds, not less than 60) for the document (if present, the document and any sub documents, annotations, or jobs linked to it will be deleted after the TTL is expired)")] = None, **kwargs):  # noqa: E501
        """Updates a document in Leia API (admin only)  # noqa: E501

        Updates metadata for a document. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_edit_document_with_http_info(token, application_id, document_id, filename, rotation_angle, ttl, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param application_id: The application to which the document to update belongs (required)
        :type application_id: str
        :param document_id: The id of the document to update (required)
        :type document_id: str
        :param filename: The new file name of the document
        :type filename: str
        :param rotation_angle: The new rotation angle of the document
        :type rotation_angle: int
        :param ttl: The TTL (in seconds, not less than 60) for the document (if present, the document and any sub documents, annotations, or jobs linked to it will be deleted after the TTL is expired)
        :type ttl: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Document, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'token',
            'application_id',
            'document_id',
            'filename',
            'rotation_angle',
            'ttl'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_edit_document" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['application_id']:
            _path_params['application_id'] = _params['application_id']
        if _params['document_id']:
            _path_params['document_id'] = _params['document_id']

        # process the query parameters
        _query_params = []
        if _params.get('filename') is not None:  # noqa: E501
            _query_params.append(('filename', _params['filename']))
        if _params.get('rotation_angle') is not None:  # noqa: E501
            _query_params.append(('rotation_angle', _params['rotation_angle']))
        if _params.get('ttl') is not None:  # noqa: E501
            _query_params.append(('ttl', _params['ttl']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['token']:
            _header_params['token'] = _params['token']

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Document",
            '401': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/admin/{application_id}/document/{document_id}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def admin_get_document(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], application_id : Annotated[StrictStr, Field(..., description="The application to which the document to retrieve belongs")], document_id : Annotated[StrictStr, Field(..., description="The id of the document to retrieve")], **kwargs) -> Document:  # noqa: E501
        """Retrieves a document from Leia API (admin only)  # noqa: E501

        Retrieves a document from Leia API as metadata. This method is only accessible to admins   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_get_document(token, application_id, document_id, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param application_id: The application to which the document to retrieve belongs (required)
        :type application_id: str
        :param document_id: The id of the document to retrieve (required)
        :type document_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Document
        """
        kwargs['_return_http_data_only'] = True
        return self.admin_get_document_with_http_info(token, application_id, document_id, **kwargs)  # noqa: E501

    @validate_arguments
    def admin_get_document_with_http_info(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], application_id : Annotated[StrictStr, Field(..., description="The application to which the document to retrieve belongs")], document_id : Annotated[StrictStr, Field(..., description="The id of the document to retrieve")], **kwargs):  # noqa: E501
        """Retrieves a document from Leia API (admin only)  # noqa: E501

        Retrieves a document from Leia API as metadata. This method is only accessible to admins   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_get_document_with_http_info(token, application_id, document_id, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param application_id: The application to which the document to retrieve belongs (required)
        :type application_id: str
        :param document_id: The id of the document to retrieve (required)
        :type document_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Document, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'token',
            'application_id',
            'document_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_get_document" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['application_id']:
            _path_params['application_id'] = _params['application_id']
        if _params['document_id']:
            _path_params['document_id'] = _params['document_id']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['token']:
            _header_params['token'] = _params['token']

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Document",
            '401': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/admin/{application_id}/document/{document_id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def admin_get_document_contents(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], application_id : Annotated[StrictStr, Field(..., description="The application to which the document to retrieve belongs")], document_id : Annotated[StrictStr, Field(..., description="The id of the document to retrieve")], max_size : Annotated[Optional[StrictInt], Field(description="Restrict the size of the image to get (only applicable for documents of type image). The largest dimension of the image will be capped to this dimension")] = None, jpeg_compression : Annotated[Optional[StrictInt], Field(description="JPEG compression rate, in percent (only applicable for documents of type image)")] = None, **kwargs) -> str:  # noqa: E501
        """Retrieves a document from Leia API (admin only)  # noqa: E501

        Retrieves the binary contents of a document from Leia API. This method is only accessible to admins   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_get_document_contents(token, application_id, document_id, max_size, jpeg_compression, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param application_id: The application to which the document to retrieve belongs (required)
        :type application_id: str
        :param document_id: The id of the document to retrieve (required)
        :type document_id: str
        :param max_size: Restrict the size of the image to get (only applicable for documents of type image). The largest dimension of the image will be capped to this dimension
        :type max_size: int
        :param jpeg_compression: JPEG compression rate, in percent (only applicable for documents of type image)
        :type jpeg_compression: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.admin_get_document_contents_with_http_info(token, application_id, document_id, max_size, jpeg_compression, **kwargs)  # noqa: E501

    @validate_arguments
    def admin_get_document_contents_with_http_info(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], application_id : Annotated[StrictStr, Field(..., description="The application to which the document to retrieve belongs")], document_id : Annotated[StrictStr, Field(..., description="The id of the document to retrieve")], max_size : Annotated[Optional[StrictInt], Field(description="Restrict the size of the image to get (only applicable for documents of type image). The largest dimension of the image will be capped to this dimension")] = None, jpeg_compression : Annotated[Optional[StrictInt], Field(description="JPEG compression rate, in percent (only applicable for documents of type image)")] = None, **kwargs):  # noqa: E501
        """Retrieves a document from Leia API (admin only)  # noqa: E501

        Retrieves the binary contents of a document from Leia API. This method is only accessible to admins   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_get_document_contents_with_http_info(token, application_id, document_id, max_size, jpeg_compression, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param application_id: The application to which the document to retrieve belongs (required)
        :type application_id: str
        :param document_id: The id of the document to retrieve (required)
        :type document_id: str
        :param max_size: Restrict the size of the image to get (only applicable for documents of type image). The largest dimension of the image will be capped to this dimension
        :type max_size: int
        :param jpeg_compression: JPEG compression rate, in percent (only applicable for documents of type image)
        :type jpeg_compression: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'token',
            'application_id',
            'document_id',
            'max_size',
            'jpeg_compression'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_get_document_contents" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['application_id']:
            _path_params['application_id'] = _params['application_id']
        if _params['document_id']:
            _path_params['document_id'] = _params['document_id']

        # process the query parameters
        _query_params = []
        if _params.get('max_size') is not None:  # noqa: E501
            _query_params.append(('max_size', _params['max_size']))
        if _params.get('jpeg_compression') is not None:  # noqa: E501
            _query_params.append(('jpeg_compression', _params['jpeg_compression']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['token']:
            _header_params['token'] = _params['token']

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "str",
            '401': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/admin/{application_id}/document/{document_id}/file_contents', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def admin_get_documents(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], document_id : Annotated[Optional[StrictStr], Field(description="The id of the document")] = None, application_id : Annotated[Optional[StrictStr], Field(description="The application that owns the documents")] = None, filename : Annotated[Optional[StrictStr], Field(description="The file name of the documents to retrieve")] = None, extension : Annotated[Optional[StrictStr], Field(description="The extension of the documents to retrieve")] = None, mime_type : Annotated[Optional[StrictStr], Field(description="Filters by MIME type")] = None, original_id : Annotated[Optional[StrictStr], Field(description="Filters by original id")] = None, tags : Annotated[Optional[List[StrictStr]], Field(description="If specified, filters the documents by tag")] = None, created_after : Annotated[Optional[datetime], Field(description="If specified, keeps only documents created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)")] = None, created_before : Annotated[Optional[datetime], Field(description="If specified, keeps only documents created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)")] = None, tag_result : Annotated[Optional[StrictStr], Field(description="Atomically adds a tag to all retrieved values if specified. The added tag will not be returned in the result")] = None, sort : Annotated[Optional[StrictStr], Field(description="If specified, sorts the documents by a list of existing parameters separated by commas. Can be 'application_id', 'filename', 'extension', 'mime_type', 'original_id', 'page', 'creation_time'. Sorts in ascending order by default. If a parameter is preceded by '-', it is sorted in descending order.")] = None, offset : Annotated[Optional[StrictInt], Field(description="Number of the first document to send (pagination)")] = None, limit : Annotated[Optional[StrictInt], Field(description="Maximum number of documents to send (pagination)")] = None, **kwargs) -> List[Document]:  # noqa: E501
        """Retrieves documents from Leia API (admin only) (paginated)  # noqa: E501

        Retrieves documents which matches the query from Leia API as JSON metadata. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_get_documents(token, document_id, application_id, filename, extension, mime_type, original_id, tags, created_after, created_before, tag_result, sort, offset, limit, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param document_id: The id of the document
        :type document_id: str
        :param application_id: The application that owns the documents
        :type application_id: str
        :param filename: The file name of the documents to retrieve
        :type filename: str
        :param extension: The extension of the documents to retrieve
        :type extension: str
        :param mime_type: Filters by MIME type
        :type mime_type: str
        :param original_id: Filters by original id
        :type original_id: str
        :param tags: If specified, filters the documents by tag
        :type tags: List[str]
        :param created_after: If specified, keeps only documents created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :type created_after: datetime
        :param created_before: If specified, keeps only documents created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :type created_before: datetime
        :param tag_result: Atomically adds a tag to all retrieved values if specified. The added tag will not be returned in the result
        :type tag_result: str
        :param sort: If specified, sorts the documents by a list of existing parameters separated by commas. Can be 'application_id', 'filename', 'extension', 'mime_type', 'original_id', 'page', 'creation_time'. Sorts in ascending order by default. If a parameter is preceded by '-', it is sorted in descending order.
        :type sort: str
        :param offset: Number of the first document to send (pagination)
        :type offset: int
        :param limit: Maximum number of documents to send (pagination)
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Document]
        """
        kwargs['_return_http_data_only'] = True
        return self.admin_get_documents_with_http_info(token, document_id, application_id, filename, extension, mime_type, original_id, tags, created_after, created_before, tag_result, sort, offset, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def admin_get_documents_with_http_info(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], document_id : Annotated[Optional[StrictStr], Field(description="The id of the document")] = None, application_id : Annotated[Optional[StrictStr], Field(description="The application that owns the documents")] = None, filename : Annotated[Optional[StrictStr], Field(description="The file name of the documents to retrieve")] = None, extension : Annotated[Optional[StrictStr], Field(description="The extension of the documents to retrieve")] = None, mime_type : Annotated[Optional[StrictStr], Field(description="Filters by MIME type")] = None, original_id : Annotated[Optional[StrictStr], Field(description="Filters by original id")] = None, tags : Annotated[Optional[List[StrictStr]], Field(description="If specified, filters the documents by tag")] = None, created_after : Annotated[Optional[datetime], Field(description="If specified, keeps only documents created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)")] = None, created_before : Annotated[Optional[datetime], Field(description="If specified, keeps only documents created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)")] = None, tag_result : Annotated[Optional[StrictStr], Field(description="Atomically adds a tag to all retrieved values if specified. The added tag will not be returned in the result")] = None, sort : Annotated[Optional[StrictStr], Field(description="If specified, sorts the documents by a list of existing parameters separated by commas. Can be 'application_id', 'filename', 'extension', 'mime_type', 'original_id', 'page', 'creation_time'. Sorts in ascending order by default. If a parameter is preceded by '-', it is sorted in descending order.")] = None, offset : Annotated[Optional[StrictInt], Field(description="Number of the first document to send (pagination)")] = None, limit : Annotated[Optional[StrictInt], Field(description="Maximum number of documents to send (pagination)")] = None, **kwargs):  # noqa: E501
        """Retrieves documents from Leia API (admin only) (paginated)  # noqa: E501

        Retrieves documents which matches the query from Leia API as JSON metadata. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_get_documents_with_http_info(token, document_id, application_id, filename, extension, mime_type, original_id, tags, created_after, created_before, tag_result, sort, offset, limit, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param document_id: The id of the document
        :type document_id: str
        :param application_id: The application that owns the documents
        :type application_id: str
        :param filename: The file name of the documents to retrieve
        :type filename: str
        :param extension: The extension of the documents to retrieve
        :type extension: str
        :param mime_type: Filters by MIME type
        :type mime_type: str
        :param original_id: Filters by original id
        :type original_id: str
        :param tags: If specified, filters the documents by tag
        :type tags: List[str]
        :param created_after: If specified, keeps only documents created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :type created_after: datetime
        :param created_before: If specified, keeps only documents created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :type created_before: datetime
        :param tag_result: Atomically adds a tag to all retrieved values if specified. The added tag will not be returned in the result
        :type tag_result: str
        :param sort: If specified, sorts the documents by a list of existing parameters separated by commas. Can be 'application_id', 'filename', 'extension', 'mime_type', 'original_id', 'page', 'creation_time'. Sorts in ascending order by default. If a parameter is preceded by '-', it is sorted in descending order.
        :type sort: str
        :param offset: Number of the first document to send (pagination)
        :type offset: int
        :param limit: Maximum number of documents to send (pagination)
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Document], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'token',
            'document_id',
            'application_id',
            'filename',
            'extension',
            'mime_type',
            'original_id',
            'tags',
            'created_after',
            'created_before',
            'tag_result',
            'sort',
            'offset',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_get_documents" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('document_id') is not None:  # noqa: E501
            _query_params.append(('document_id', _params['document_id']))
        if _params.get('application_id') is not None:  # noqa: E501
            _query_params.append(('application_id', _params['application_id']))
        if _params.get('filename') is not None:  # noqa: E501
            _query_params.append(('filename', _params['filename']))
        if _params.get('extension') is not None:  # noqa: E501
            _query_params.append(('extension', _params['extension']))
        if _params.get('mime_type') is not None:  # noqa: E501
            _query_params.append(('mime_type', _params['mime_type']))
        if _params.get('original_id') is not None:  # noqa: E501
            _query_params.append(('original_id', _params['original_id']))
        if _params.get('tags') is not None:  # noqa: E501
            _query_params.append(('tags', _params['tags']))
            _collection_formats['tags'] = 'multi'
        if _params.get('created_after') is not None:  # noqa: E501
            _query_params.append(('created_after', _params['created_after']))
        if _params.get('created_before') is not None:  # noqa: E501
            _query_params.append(('created_before', _params['created_before']))
        if _params.get('tag_result') is not None:  # noqa: E501
            _query_params.append(('tag_result', _params['tag_result']))
        if _params.get('sort') is not None:  # noqa: E501
            _query_params.append(('sort', _params['sort']))
        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))
        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['token']:
            _header_params['token'] = _params['token']

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[Document]",
            '401': None,
            '403': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/admin/document', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def admin_get_documents_tags(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], application_id : Annotated[Optional[StrictStr], Field(description="Restrict to tags belonging to this application")] = None, **kwargs) -> List[str]:  # noqa: E501
        """Retrieves documents' tags from Leia API (admin only)  # noqa: E501

        Retrieves tags from documents. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_get_documents_tags(token, application_id, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param application_id: Restrict to tags belonging to this application
        :type application_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[str]
        """
        kwargs['_return_http_data_only'] = True
        return self.admin_get_documents_tags_with_http_info(token, application_id, **kwargs)  # noqa: E501

    @validate_arguments
    def admin_get_documents_tags_with_http_info(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], application_id : Annotated[Optional[StrictStr], Field(description="Restrict to tags belonging to this application")] = None, **kwargs):  # noqa: E501
        """Retrieves documents' tags from Leia API (admin only)  # noqa: E501

        Retrieves tags from documents. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_get_documents_tags_with_http_info(token, application_id, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param application_id: Restrict to tags belonging to this application
        :type application_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[str], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'token',
            'application_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_get_documents_tags" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('application_id') is not None:  # noqa: E501
            _query_params.append(('application_id', _params['application_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['token']:
            _header_params['token'] = _params['token']

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[str]",
            '401': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/admin/document/tag', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def admin_get_documents_zip(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], document_id : Annotated[Optional[StrictStr], Field(description="The id of the document")] = None, application_id : Annotated[Optional[StrictStr], Field(description="The application that owns the documents")] = None, filename : Annotated[Optional[StrictStr], Field(description="The file name of the documents to retrieve")] = None, extension : Annotated[Optional[StrictStr], Field(description="The extension of the documents to retrieve")] = None, mime_type : Annotated[Optional[StrictStr], Field(description="Filters by MIME type")] = None, original_id : Annotated[Optional[StrictStr], Field(description="Filters by original id")] = None, tags : Annotated[Optional[List[StrictStr]], Field(description="If specified, filters the documents by tag")] = None, created_after : Annotated[Optional[datetime], Field(description="If specified, keeps only documents created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)")] = None, created_before : Annotated[Optional[datetime], Field(description="If specified, keeps only documents created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)")] = None, **kwargs) -> str:  # noqa: E501
        """Retrieves documents from Leia API (admin only) (paginated)  # noqa: E501

        Retrieves documents which matches the query from Leia API in a zip file. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_get_documents_zip(token, document_id, application_id, filename, extension, mime_type, original_id, tags, created_after, created_before, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param document_id: The id of the document
        :type document_id: str
        :param application_id: The application that owns the documents
        :type application_id: str
        :param filename: The file name of the documents to retrieve
        :type filename: str
        :param extension: The extension of the documents to retrieve
        :type extension: str
        :param mime_type: Filters by MIME type
        :type mime_type: str
        :param original_id: Filters by original id
        :type original_id: str
        :param tags: If specified, filters the documents by tag
        :type tags: List[str]
        :param created_after: If specified, keeps only documents created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :type created_after: datetime
        :param created_before: If specified, keeps only documents created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :type created_before: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.admin_get_documents_zip_with_http_info(token, document_id, application_id, filename, extension, mime_type, original_id, tags, created_after, created_before, **kwargs)  # noqa: E501

    @validate_arguments
    def admin_get_documents_zip_with_http_info(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], document_id : Annotated[Optional[StrictStr], Field(description="The id of the document")] = None, application_id : Annotated[Optional[StrictStr], Field(description="The application that owns the documents")] = None, filename : Annotated[Optional[StrictStr], Field(description="The file name of the documents to retrieve")] = None, extension : Annotated[Optional[StrictStr], Field(description="The extension of the documents to retrieve")] = None, mime_type : Annotated[Optional[StrictStr], Field(description="Filters by MIME type")] = None, original_id : Annotated[Optional[StrictStr], Field(description="Filters by original id")] = None, tags : Annotated[Optional[List[StrictStr]], Field(description="If specified, filters the documents by tag")] = None, created_after : Annotated[Optional[datetime], Field(description="If specified, keeps only documents created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)")] = None, created_before : Annotated[Optional[datetime], Field(description="If specified, keeps only documents created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)")] = None, **kwargs):  # noqa: E501
        """Retrieves documents from Leia API (admin only) (paginated)  # noqa: E501

        Retrieves documents which matches the query from Leia API in a zip file. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_get_documents_zip_with_http_info(token, document_id, application_id, filename, extension, mime_type, original_id, tags, created_after, created_before, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param document_id: The id of the document
        :type document_id: str
        :param application_id: The application that owns the documents
        :type application_id: str
        :param filename: The file name of the documents to retrieve
        :type filename: str
        :param extension: The extension of the documents to retrieve
        :type extension: str
        :param mime_type: Filters by MIME type
        :type mime_type: str
        :param original_id: Filters by original id
        :type original_id: str
        :param tags: If specified, filters the documents by tag
        :type tags: List[str]
        :param created_after: If specified, keeps only documents created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :type created_after: datetime
        :param created_before: If specified, keeps only documents created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :type created_before: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'token',
            'document_id',
            'application_id',
            'filename',
            'extension',
            'mime_type',
            'original_id',
            'tags',
            'created_after',
            'created_before'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_get_documents_zip" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('document_id') is not None:  # noqa: E501
            _query_params.append(('document_id', _params['document_id']))
        if _params.get('application_id') is not None:  # noqa: E501
            _query_params.append(('application_id', _params['application_id']))
        if _params.get('filename') is not None:  # noqa: E501
            _query_params.append(('filename', _params['filename']))
        if _params.get('extension') is not None:  # noqa: E501
            _query_params.append(('extension', _params['extension']))
        if _params.get('mime_type') is not None:  # noqa: E501
            _query_params.append(('mime_type', _params['mime_type']))
        if _params.get('original_id') is not None:  # noqa: E501
            _query_params.append(('original_id', _params['original_id']))
        if _params.get('tags') is not None:  # noqa: E501
            _query_params.append(('tags', _params['tags']))
            _collection_formats['tags'] = 'multi'
        if _params.get('created_after') is not None:  # noqa: E501
            _query_params.append(('created_after', _params['created_after']))
        if _params.get('created_before') is not None:  # noqa: E501
            _query_params.append(('created_before', _params['created_before']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['token']:
            _header_params['token'] = _params['token']

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/zip'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "str",
            '401': None,
            '403': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/admin/document/zip', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def admin_tag_document(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], application_id : Annotated[StrictStr, Field(..., description="The application to which the document to tag belongs")], document_id : Annotated[StrictStr, Field(..., description="The id of the document")], tag : Annotated[StrictStr, Field(..., description="The tag to add to the document")], **kwargs) -> Document:  # noqa: E501
        """Tags a document (admin only)  # noqa: E501

        Tags a document. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_tag_document(token, application_id, document_id, tag, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param application_id: The application to which the document to tag belongs (required)
        :type application_id: str
        :param document_id: The id of the document (required)
        :type document_id: str
        :param tag: The tag to add to the document (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Document
        """
        kwargs['_return_http_data_only'] = True
        return self.admin_tag_document_with_http_info(token, application_id, document_id, tag, **kwargs)  # noqa: E501

    @validate_arguments
    def admin_tag_document_with_http_info(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], application_id : Annotated[StrictStr, Field(..., description="The application to which the document to tag belongs")], document_id : Annotated[StrictStr, Field(..., description="The id of the document")], tag : Annotated[StrictStr, Field(..., description="The tag to add to the document")], **kwargs):  # noqa: E501
        """Tags a document (admin only)  # noqa: E501

        Tags a document. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_tag_document_with_http_info(token, application_id, document_id, tag, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param application_id: The application to which the document to tag belongs (required)
        :type application_id: str
        :param document_id: The id of the document (required)
        :type document_id: str
        :param tag: The tag to add to the document (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Document, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'token',
            'application_id',
            'document_id',
            'tag'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_tag_document" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['application_id']:
            _path_params['application_id'] = _params['application_id']
        if _params['document_id']:
            _path_params['document_id'] = _params['document_id']
        if _params['tag']:
            _path_params['tag'] = _params['tag']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['token']:
            _header_params['token'] = _params['token']

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Document",
            '401': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/admin/{application_id}/document/{document_id}/tag/{tag}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def admin_transform_document_async(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], application_id : Annotated[StrictStr, Field(..., description="The application id whose documents to transform belong to")], document_ids : Annotated[List[StrictStr], Field(..., description="Comma separated list of document ids to process")], output_type : Annotated[TransformTypes, Field(..., description="The output type. May be:   * image (extract one image for each page in a PDF file)   * text (Use OCR on an image to get convert it to text)     * To use an OCR different from the normal LEIA OCR, add \"ocr\":google_vision or \"ocr\":paddle in transform_params   * text_tree (text in the form of a JSON tree with information about text blocks and their position in the document)     * To use an OCR different from the normal LEIA OCR, add \"ocr\":google_vision or \"ocr\":paddle in transform_params   * autorotate (Rotates an image that contains text so that it is in readable orientation)   * trim (Trims white space around a document)   * merge (Merge multiple text documents into a single one with a carriage return '\\n' between them)   * split (Splits a text document into chunks of 1000 words and replaces all spacing characters by single spaces (this number can be changed by setting split_size to another value in transform_params)) ")], input_tag : Annotated[Optional[StrictStr], Field(description="The tag of the documents to process. If tag is present, document_ids should contain a single value, and the documents processed will be those where original_id=document_ids[0] and that contain the specified tag")] = None, output_tag : Annotated[Optional[StrictStr], Field(description="The tag to add to the documents resulting from the transformation")] = None, execute_after_id : Annotated[Optional[StrictStr], Field(description="The id of a job that must be in PROCESSED status before this one can be started (used to chain jobs even before the first ones are terminated). If the referenced job becomes FAILED or is CANCELED, this one will fail")] = None, page_range : Annotated[Optional[StrictStr], Field(description="The pages that should be used in previous job to process this one. Can only be used if execute_after_id is not null. Pages are indexed from 0. Syntax is the same as Python slices syntax (https://docs.python.org/3/whatsnew/2.3.html#extended-slices). Examples :   * Single positive integer : keep only this page (example 4 will keep only page 5 (Remember, pages are indexed from 0))   * Single negative integer : keep only this page, but starting from the end (example -4 will keep only page 7 if there are 10 total pages)   * Range (x:y) : keep only this range of pages (Including x but excluding y, indexed from 0)     Examples       * 2: will keep all pages starting from page 3       * :5 will keep only pages 1 to 5       * 2:5 will keep only pages 3, 4 and 5       * -4: will keep only pages 7 to 10 if there are 10 total pages)       * :-2 will keep only pages 1 to 8 if there are 10 total pages)       * -4:-2 will keep only pages 7 and 8 if there are 10 total pages)   * Stride (::w) : Keep 1 page every w pages starting at the first one (example ::2 will keep only odd pages)   * Range and stride (x:y:w) : Keep 1 page every w pages within range (x:y) (example 1::2 will keep only even pages) You can use multiple ranges of page at once, comma separated (For example, 0,2:5,-2:-1 keeps the 1st page, plus pages 3->5, plus the second to last page) ")] = None, callback_url : Annotated[Optional[StrictStr], Field(description="Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.")] = None, transform_params : Annotated[Optional[Dict[str, StrictStr]], Field(description="Free form parameters for the transformation")] = None, block_processing : Annotated[Optional[StrictBool], Field(description="If true, blocks processing on the job until /job/{id}/start is called. Default is false")] = None, transform_body : Annotated[Optional[TransformBody], Field(description="All the previous query parameters can also be passed as JSON in the body of the request")] = None, **kwargs) -> Job:  # noqa: E501
        """Asynchronously converts a document within Leia API (admin only)  # noqa: E501

        Asynchronously transforms a document from its current type to the output_type. May generate multiple new documents (for example converting a PDF to image will generate one new image document for each page of the PDF). Returns a Job, that will have to be polled to get the result. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_transform_document_async(token, application_id, document_ids, output_type, input_tag, output_tag, execute_after_id, page_range, callback_url, transform_params, block_processing, transform_body, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param application_id: The application id whose documents to transform belong to (required)
        :type application_id: str
        :param document_ids: Comma separated list of document ids to process (required)
        :type document_ids: List[str]
        :param output_type: The output type. May be:   * image (extract one image for each page in a PDF file)   * text (Use OCR on an image to get convert it to text)     * To use an OCR different from the normal LEIA OCR, add \"ocr\":google_vision or \"ocr\":paddle in transform_params   * text_tree (text in the form of a JSON tree with information about text blocks and their position in the document)     * To use an OCR different from the normal LEIA OCR, add \"ocr\":google_vision or \"ocr\":paddle in transform_params   * autorotate (Rotates an image that contains text so that it is in readable orientation)   * trim (Trims white space around a document)   * merge (Merge multiple text documents into a single one with a carriage return '\\n' between them)   * split (Splits a text document into chunks of 1000 words and replaces all spacing characters by single spaces (this number can be changed by setting split_size to another value in transform_params))  (required)
        :type output_type: TransformTypes
        :param input_tag: The tag of the documents to process. If tag is present, document_ids should contain a single value, and the documents processed will be those where original_id=document_ids[0] and that contain the specified tag
        :type input_tag: str
        :param output_tag: The tag to add to the documents resulting from the transformation
        :type output_tag: str
        :param execute_after_id: The id of a job that must be in PROCESSED status before this one can be started (used to chain jobs even before the first ones are terminated). If the referenced job becomes FAILED or is CANCELED, this one will fail
        :type execute_after_id: str
        :param page_range: The pages that should be used in previous job to process this one. Can only be used if execute_after_id is not null. Pages are indexed from 0. Syntax is the same as Python slices syntax (https://docs.python.org/3/whatsnew/2.3.html#extended-slices). Examples :   * Single positive integer : keep only this page (example 4 will keep only page 5 (Remember, pages are indexed from 0))   * Single negative integer : keep only this page, but starting from the end (example -4 will keep only page 7 if there are 10 total pages)   * Range (x:y) : keep only this range of pages (Including x but excluding y, indexed from 0)     Examples       * 2: will keep all pages starting from page 3       * :5 will keep only pages 1 to 5       * 2:5 will keep only pages 3, 4 and 5       * -4: will keep only pages 7 to 10 if there are 10 total pages)       * :-2 will keep only pages 1 to 8 if there are 10 total pages)       * -4:-2 will keep only pages 7 and 8 if there are 10 total pages)   * Stride (::w) : Keep 1 page every w pages starting at the first one (example ::2 will keep only odd pages)   * Range and stride (x:y:w) : Keep 1 page every w pages within range (x:y) (example 1::2 will keep only even pages) You can use multiple ranges of page at once, comma separated (For example, 0,2:5,-2:-1 keeps the 1st page, plus pages 3->5, plus the second to last page) 
        :type page_range: str
        :param callback_url: Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.
        :type callback_url: str
        :param transform_params: Free form parameters for the transformation
        :type transform_params: object
        :param block_processing: If true, blocks processing on the job until /job/{id}/start is called. Default is false
        :type block_processing: bool
        :param transform_body: All the previous query parameters can also be passed as JSON in the body of the request
        :type transform_body: TransformBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Job
        """
        kwargs['_return_http_data_only'] = True
        return self.admin_transform_document_async_with_http_info(token, application_id, document_ids, output_type, input_tag, output_tag, execute_after_id, page_range, callback_url, transform_params, block_processing, transform_body, **kwargs)  # noqa: E501

    @validate_arguments
    def admin_transform_document_async_with_http_info(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], application_id : Annotated[StrictStr, Field(..., description="The application id whose documents to transform belong to")], document_ids : Annotated[List[StrictStr], Field(..., description="Comma separated list of document ids to process")], output_type : Annotated[TransformTypes, Field(..., description="The output type. May be:   * image (extract one image for each page in a PDF file)   * text (Use OCR on an image to get convert it to text)     * To use an OCR different from the normal LEIA OCR, add \"ocr\":google_vision or \"ocr\":paddle in transform_params   * text_tree (text in the form of a JSON tree with information about text blocks and their position in the document)     * To use an OCR different from the normal LEIA OCR, add \"ocr\":google_vision or \"ocr\":paddle in transform_params   * autorotate (Rotates an image that contains text so that it is in readable orientation)   * trim (Trims white space around a document)   * merge (Merge multiple text documents into a single one with a carriage return '\\n' between them)   * split (Splits a text document into chunks of 1000 words and replaces all spacing characters by single spaces (this number can be changed by setting split_size to another value in transform_params)) ")], input_tag : Annotated[Optional[StrictStr], Field(description="The tag of the documents to process. If tag is present, document_ids should contain a single value, and the documents processed will be those where original_id=document_ids[0] and that contain the specified tag")] = None, output_tag : Annotated[Optional[StrictStr], Field(description="The tag to add to the documents resulting from the transformation")] = None, execute_after_id : Annotated[Optional[StrictStr], Field(description="The id of a job that must be in PROCESSED status before this one can be started (used to chain jobs even before the first ones are terminated). If the referenced job becomes FAILED or is CANCELED, this one will fail")] = None, page_range : Annotated[Optional[StrictStr], Field(description="The pages that should be used in previous job to process this one. Can only be used if execute_after_id is not null. Pages are indexed from 0. Syntax is the same as Python slices syntax (https://docs.python.org/3/whatsnew/2.3.html#extended-slices). Examples :   * Single positive integer : keep only this page (example 4 will keep only page 5 (Remember, pages are indexed from 0))   * Single negative integer : keep only this page, but starting from the end (example -4 will keep only page 7 if there are 10 total pages)   * Range (x:y) : keep only this range of pages (Including x but excluding y, indexed from 0)     Examples       * 2: will keep all pages starting from page 3       * :5 will keep only pages 1 to 5       * 2:5 will keep only pages 3, 4 and 5       * -4: will keep only pages 7 to 10 if there are 10 total pages)       * :-2 will keep only pages 1 to 8 if there are 10 total pages)       * -4:-2 will keep only pages 7 and 8 if there are 10 total pages)   * Stride (::w) : Keep 1 page every w pages starting at the first one (example ::2 will keep only odd pages)   * Range and stride (x:y:w) : Keep 1 page every w pages within range (x:y) (example 1::2 will keep only even pages) You can use multiple ranges of page at once, comma separated (For example, 0,2:5,-2:-1 keeps the 1st page, plus pages 3->5, plus the second to last page) ")] = None, callback_url : Annotated[Optional[StrictStr], Field(description="Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.")] = None, transform_params : Annotated[Optional[Dict[str, StrictStr]], Field(description="Free form parameters for the transformation")] = None, block_processing : Annotated[Optional[StrictBool], Field(description="If true, blocks processing on the job until /job/{id}/start is called. Default is false")] = None, transform_body : Annotated[Optional[TransformBody], Field(description="All the previous query parameters can also be passed as JSON in the body of the request")] = None, **kwargs):  # noqa: E501
        """Asynchronously converts a document within Leia API (admin only)  # noqa: E501

        Asynchronously transforms a document from its current type to the output_type. May generate multiple new documents (for example converting a PDF to image will generate one new image document for each page of the PDF). Returns a Job, that will have to be polled to get the result. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_transform_document_async_with_http_info(token, application_id, document_ids, output_type, input_tag, output_tag, execute_after_id, page_range, callback_url, transform_params, block_processing, transform_body, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param application_id: The application id whose documents to transform belong to (required)
        :type application_id: str
        :param document_ids: Comma separated list of document ids to process (required)
        :type document_ids: List[str]
        :param output_type: The output type. May be:   * image (extract one image for each page in a PDF file)   * text (Use OCR on an image to get convert it to text)     * To use an OCR different from the normal LEIA OCR, add \"ocr\":google_vision or \"ocr\":paddle in transform_params   * text_tree (text in the form of a JSON tree with information about text blocks and their position in the document)     * To use an OCR different from the normal LEIA OCR, add \"ocr\":google_vision or \"ocr\":paddle in transform_params   * autorotate (Rotates an image that contains text so that it is in readable orientation)   * trim (Trims white space around a document)   * merge (Merge multiple text documents into a single one with a carriage return '\\n' between them)   * split (Splits a text document into chunks of 1000 words and replaces all spacing characters by single spaces (this number can be changed by setting split_size to another value in transform_params))  (required)
        :type output_type: TransformTypes
        :param input_tag: The tag of the documents to process. If tag is present, document_ids should contain a single value, and the documents processed will be those where original_id=document_ids[0] and that contain the specified tag
        :type input_tag: str
        :param output_tag: The tag to add to the documents resulting from the transformation
        :type output_tag: str
        :param execute_after_id: The id of a job that must be in PROCESSED status before this one can be started (used to chain jobs even before the first ones are terminated). If the referenced job becomes FAILED or is CANCELED, this one will fail
        :type execute_after_id: str
        :param page_range: The pages that should be used in previous job to process this one. Can only be used if execute_after_id is not null. Pages are indexed from 0. Syntax is the same as Python slices syntax (https://docs.python.org/3/whatsnew/2.3.html#extended-slices). Examples :   * Single positive integer : keep only this page (example 4 will keep only page 5 (Remember, pages are indexed from 0))   * Single negative integer : keep only this page, but starting from the end (example -4 will keep only page 7 if there are 10 total pages)   * Range (x:y) : keep only this range of pages (Including x but excluding y, indexed from 0)     Examples       * 2: will keep all pages starting from page 3       * :5 will keep only pages 1 to 5       * 2:5 will keep only pages 3, 4 and 5       * -4: will keep only pages 7 to 10 if there are 10 total pages)       * :-2 will keep only pages 1 to 8 if there are 10 total pages)       * -4:-2 will keep only pages 7 and 8 if there are 10 total pages)   * Stride (::w) : Keep 1 page every w pages starting at the first one (example ::2 will keep only odd pages)   * Range and stride (x:y:w) : Keep 1 page every w pages within range (x:y) (example 1::2 will keep only even pages) You can use multiple ranges of page at once, comma separated (For example, 0,2:5,-2:-1 keeps the 1st page, plus pages 3->5, plus the second to last page) 
        :type page_range: str
        :param callback_url: Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.
        :type callback_url: str
        :param transform_params: Free form parameters for the transformation
        :type transform_params: object
        :param block_processing: If true, blocks processing on the job until /job/{id}/start is called. Default is false
        :type block_processing: bool
        :param transform_body: All the previous query parameters can also be passed as JSON in the body of the request
        :type transform_body: TransformBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Job, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'token',
            'application_id',
            'document_ids',
            'output_type',
            'input_tag',
            'output_tag',
            'execute_after_id',
            'page_range',
            'callback_url',
            'transform_params',
            'block_processing',
            'transform_body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_transform_document_async" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['application_id']:
            _path_params['application_id'] = _params['application_id']
        if _params['document_ids']:
            _path_params['document_ids'] = _params['document_ids']
            _collection_formats['document_ids'] = 'csv'
        if _params['output_type']:
            _path_params['output_type'] = _params['output_type']

        # process the query parameters
        _query_params = []
        if _params.get('input_tag') is not None:  # noqa: E501
            _query_params.append(('input_tag', _params['input_tag']))
        if _params.get('output_tag') is not None:  # noqa: E501
            _query_params.append(('output_tag', _params['output_tag']))
        if _params.get('execute_after_id') is not None:  # noqa: E501
            _query_params.append(('execute_after_id', _params['execute_after_id']))
        if _params.get('page_range') is not None:  # noqa: E501
            _query_params.append(('page_range', _params['page_range']))
        if _params.get('callback_url') is not None:  # noqa: E501
            _query_params.append(('callback_url', _params['callback_url']))
        if _params.get('transform_params') is not None:  # noqa: E501
            _query_params.append(('transform_params', _params['transform_params']))
        if _params.get('block_processing') is not None:  # noqa: E501
            _query_params.append(('block_processing', _params['block_processing']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['token']:
            _header_params['token'] = _params['token']

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params['transform_body']:
            _body_params = _params['transform_body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Job",
            '401': None,
            '403': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/admin/{application_id}/document/{document_ids}/transform/{output_type}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def admin_untag_document(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], application_id : Annotated[StrictStr, Field(..., description="The application to which the document to untag belongs")], document_id : Annotated[StrictStr, Field(..., description="The id of the document")], tag : Annotated[StrictStr, Field(..., description="The tag to delete from the document")], **kwargs) -> None:  # noqa: E501
        """Untags an document (admin only)  # noqa: E501

        Untags a document. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_untag_document(token, application_id, document_id, tag, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param application_id: The application to which the document to untag belongs (required)
        :type application_id: str
        :param document_id: The id of the document (required)
        :type document_id: str
        :param tag: The tag to delete from the document (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.admin_untag_document_with_http_info(token, application_id, document_id, tag, **kwargs)  # noqa: E501

    @validate_arguments
    def admin_untag_document_with_http_info(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], application_id : Annotated[StrictStr, Field(..., description="The application to which the document to untag belongs")], document_id : Annotated[StrictStr, Field(..., description="The id of the document")], tag : Annotated[StrictStr, Field(..., description="The tag to delete from the document")], **kwargs):  # noqa: E501
        """Untags an document (admin only)  # noqa: E501

        Untags a document. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_untag_document_with_http_info(token, application_id, document_id, tag, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param application_id: The application to which the document to untag belongs (required)
        :type application_id: str
        :param document_id: The id of the document (required)
        :type document_id: str
        :param tag: The tag to delete from the document (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'token',
            'application_id',
            'document_id',
            'tag'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_untag_document" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['application_id']:
            _path_params['application_id'] = _params['application_id']
        if _params['document_id']:
            _path_params['document_id'] = _params['document_id']
        if _params['tag']:
            _path_params['tag'] = _params['tag']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['token']:
            _header_params['token'] = _params['token']

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/admin/{application_id}/document/{document_id}/tag/{tag}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
