# coding: utf-8

"""
    LEIA RESTful API for AI

    Leia API  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Contact: contact@leia.io
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from datetime import datetime

from pydantic import Field, StrictBool, StrictInt, StrictStr

from typing import Dict, List, Optional

from leiaapi.generated.models.apply_body import ApplyBody
from leiaapi.generated.models.format_types import FormatTypes
from leiaapi.generated.models.job import Job
from leiaapi.generated.models.model import Model
from leiaapi.generated.models.model_input_types import ModelInputTypes
from leiaapi.generated.models.model_types import ModelTypes
from leiaapi.generated.models.train_body import TrainBody

from leiaapi.generated.api_client import ApiClient
from leiaapi.generated.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class ModelApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def apply_model_async(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], model_id : Annotated[StrictStr, Field(..., description="The id or the short name of the model to apply on the document")], document_ids : Annotated[List[StrictStr], Field(..., description="Comma separated list of document ids to process")], tag : Annotated[Optional[StrictStr], Field(description="The tag of the documents to process. If tag is present, document_ids should contain a single value, and the documents processed will be those where original_id=document_ids[0] and that contain the specified tag")] = None, format_type : Annotated[Optional[FormatTypes], Field(description="The format in which the data should be returned. If empty, will return an array of key-value items. If it is classification, the result will be a Classification object.")] = None, execute_after_id : Annotated[Optional[StrictStr], Field(description="The id of a job that must be in PROCESSED status before this one can be started (used to chain jobs even before the first ones are terminated). If the referenced job becomes FAILED or is CANCELED, this one will fail")] = None, page_range : Annotated[Optional[StrictStr], Field(description="The pages that should be used in previous job to process this one. Can only be used if execute_after_id is not null. Pages are indexed from 0. Syntax is the same as Python slices syntax (https://docs.python.org/3/whatsnew/2.3.html#extended-slices). Examples :   * Single positive integer : keep only this page (example 4 will keep only page 5 (Remember, pages are indexed from 0))   * Single negative integer : keep only this page, but starting from the end (example -4 will keep only page 7 if there are 10 total pages)   * Range (x:y) : keep only this range of pages (Including x but excluding y, indexed from 0)     Examples       * 2: will keep all pages starting from page 3       * :5 will keep only pages 1 to 5       * 2:5 will keep only pages 3, 4 and 5       * -4: will keep only pages 7 to 10 if there are 10 total pages)       * :-2 will keep only pages 1 to 8 if there are 10 total pages)       * -4:-2 will keep only pages 7 and 8 if there are 10 total pages)   * Stride (::w) : Keep 1 page every w pages starting at the first one (example ::2 will keep only odd pages)   * Range and stride (x:y:w) : Keep 1 page every w pages within range (x:y) (example 1::2 will keep only even pages)  You can use multiple ranges of page at once, comma separated (For example, 0,2:5,-2:-1 keeps the 1st page, plus pages 3->5, plus the second to last page) ")] = None, callback_url : Annotated[Optional[StrictStr], Field(description="Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.")] = None, save_result : Annotated[Optional[StrictBool], Field(description="If you want to save the result as a json document")] = None, model_params : Annotated[Optional[Dict[str, StrictStr]], Field(description="Additional parameters that will be passed as is to the model.")] = None, block_processing : Annotated[Optional[StrictBool], Field(description="If true, blocks processing on the job until /job/{id}/start is called. Default is false")] = None, apply_body : Annotated[Optional[ApplyBody], Field(description="All the previous query parameters can also be passed as JSON in the body of the request")] = None, **kwargs) -> Job:  # noqa: E501
        """Asynchronously applies a model on documents  # noqa: E501

        Asynchronously applies an accessible model on accessible documents and returns a Job, that will have to be polled to get the result  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.apply_model_async(token, model_id, document_ids, tag, format_type, execute_after_id, page_range, callback_url, save_result, model_params, block_processing, apply_body, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param model_id: The id or the short name of the model to apply on the document (required)
        :type model_id: str
        :param document_ids: Comma separated list of document ids to process (required)
        :type document_ids: List[str]
        :param tag: The tag of the documents to process. If tag is present, document_ids should contain a single value, and the documents processed will be those where original_id=document_ids[0] and that contain the specified tag
        :type tag: str
        :param format_type: The format in which the data should be returned. If empty, will return an array of key-value items. If it is classification, the result will be a Classification object.
        :type format_type: FormatTypes
        :param execute_after_id: The id of a job that must be in PROCESSED status before this one can be started (used to chain jobs even before the first ones are terminated). If the referenced job becomes FAILED or is CANCELED, this one will fail
        :type execute_after_id: str
        :param page_range: The pages that should be used in previous job to process this one. Can only be used if execute_after_id is not null. Pages are indexed from 0. Syntax is the same as Python slices syntax (https://docs.python.org/3/whatsnew/2.3.html#extended-slices). Examples :   * Single positive integer : keep only this page (example 4 will keep only page 5 (Remember, pages are indexed from 0))   * Single negative integer : keep only this page, but starting from the end (example -4 will keep only page 7 if there are 10 total pages)   * Range (x:y) : keep only this range of pages (Including x but excluding y, indexed from 0)     Examples       * 2: will keep all pages starting from page 3       * :5 will keep only pages 1 to 5       * 2:5 will keep only pages 3, 4 and 5       * -4: will keep only pages 7 to 10 if there are 10 total pages)       * :-2 will keep only pages 1 to 8 if there are 10 total pages)       * -4:-2 will keep only pages 7 and 8 if there are 10 total pages)   * Stride (::w) : Keep 1 page every w pages starting at the first one (example ::2 will keep only odd pages)   * Range and stride (x:y:w) : Keep 1 page every w pages within range (x:y) (example 1::2 will keep only even pages)  You can use multiple ranges of page at once, comma separated (For example, 0,2:5,-2:-1 keeps the 1st page, plus pages 3->5, plus the second to last page) 
        :type page_range: str
        :param callback_url: Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.
        :type callback_url: str
        :param save_result: If you want to save the result as a json document
        :type save_result: bool
        :param model_params: Additional parameters that will be passed as is to the model.
        :type model_params: object
        :param block_processing: If true, blocks processing on the job until /job/{id}/start is called. Default is false
        :type block_processing: bool
        :param apply_body: All the previous query parameters can also be passed as JSON in the body of the request
        :type apply_body: ApplyBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Job
        """
        kwargs['_return_http_data_only'] = True
        return self.apply_model_async_with_http_info(token, model_id, document_ids, tag, format_type, execute_after_id, page_range, callback_url, save_result, model_params, block_processing, apply_body, **kwargs)  # noqa: E501

    @validate_arguments
    def apply_model_async_with_http_info(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], model_id : Annotated[StrictStr, Field(..., description="The id or the short name of the model to apply on the document")], document_ids : Annotated[List[StrictStr], Field(..., description="Comma separated list of document ids to process")], tag : Annotated[Optional[StrictStr], Field(description="The tag of the documents to process. If tag is present, document_ids should contain a single value, and the documents processed will be those where original_id=document_ids[0] and that contain the specified tag")] = None, format_type : Annotated[Optional[FormatTypes], Field(description="The format in which the data should be returned. If empty, will return an array of key-value items. If it is classification, the result will be a Classification object.")] = None, execute_after_id : Annotated[Optional[StrictStr], Field(description="The id of a job that must be in PROCESSED status before this one can be started (used to chain jobs even before the first ones are terminated). If the referenced job becomes FAILED or is CANCELED, this one will fail")] = None, page_range : Annotated[Optional[StrictStr], Field(description="The pages that should be used in previous job to process this one. Can only be used if execute_after_id is not null. Pages are indexed from 0. Syntax is the same as Python slices syntax (https://docs.python.org/3/whatsnew/2.3.html#extended-slices). Examples :   * Single positive integer : keep only this page (example 4 will keep only page 5 (Remember, pages are indexed from 0))   * Single negative integer : keep only this page, but starting from the end (example -4 will keep only page 7 if there are 10 total pages)   * Range (x:y) : keep only this range of pages (Including x but excluding y, indexed from 0)     Examples       * 2: will keep all pages starting from page 3       * :5 will keep only pages 1 to 5       * 2:5 will keep only pages 3, 4 and 5       * -4: will keep only pages 7 to 10 if there are 10 total pages)       * :-2 will keep only pages 1 to 8 if there are 10 total pages)       * -4:-2 will keep only pages 7 and 8 if there are 10 total pages)   * Stride (::w) : Keep 1 page every w pages starting at the first one (example ::2 will keep only odd pages)   * Range and stride (x:y:w) : Keep 1 page every w pages within range (x:y) (example 1::2 will keep only even pages)  You can use multiple ranges of page at once, comma separated (For example, 0,2:5,-2:-1 keeps the 1st page, plus pages 3->5, plus the second to last page) ")] = None, callback_url : Annotated[Optional[StrictStr], Field(description="Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.")] = None, save_result : Annotated[Optional[StrictBool], Field(description="If you want to save the result as a json document")] = None, model_params : Annotated[Optional[Dict[str, StrictStr]], Field(description="Additional parameters that will be passed as is to the model.")] = None, block_processing : Annotated[Optional[StrictBool], Field(description="If true, blocks processing on the job until /job/{id}/start is called. Default is false")] = None, apply_body : Annotated[Optional[ApplyBody], Field(description="All the previous query parameters can also be passed as JSON in the body of the request")] = None, **kwargs):  # noqa: E501
        """Asynchronously applies a model on documents  # noqa: E501

        Asynchronously applies an accessible model on accessible documents and returns a Job, that will have to be polled to get the result  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.apply_model_async_with_http_info(token, model_id, document_ids, tag, format_type, execute_after_id, page_range, callback_url, save_result, model_params, block_processing, apply_body, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param model_id: The id or the short name of the model to apply on the document (required)
        :type model_id: str
        :param document_ids: Comma separated list of document ids to process (required)
        :type document_ids: List[str]
        :param tag: The tag of the documents to process. If tag is present, document_ids should contain a single value, and the documents processed will be those where original_id=document_ids[0] and that contain the specified tag
        :type tag: str
        :param format_type: The format in which the data should be returned. If empty, will return an array of key-value items. If it is classification, the result will be a Classification object.
        :type format_type: FormatTypes
        :param execute_after_id: The id of a job that must be in PROCESSED status before this one can be started (used to chain jobs even before the first ones are terminated). If the referenced job becomes FAILED or is CANCELED, this one will fail
        :type execute_after_id: str
        :param page_range: The pages that should be used in previous job to process this one. Can only be used if execute_after_id is not null. Pages are indexed from 0. Syntax is the same as Python slices syntax (https://docs.python.org/3/whatsnew/2.3.html#extended-slices). Examples :   * Single positive integer : keep only this page (example 4 will keep only page 5 (Remember, pages are indexed from 0))   * Single negative integer : keep only this page, but starting from the end (example -4 will keep only page 7 if there are 10 total pages)   * Range (x:y) : keep only this range of pages (Including x but excluding y, indexed from 0)     Examples       * 2: will keep all pages starting from page 3       * :5 will keep only pages 1 to 5       * 2:5 will keep only pages 3, 4 and 5       * -4: will keep only pages 7 to 10 if there are 10 total pages)       * :-2 will keep only pages 1 to 8 if there are 10 total pages)       * -4:-2 will keep only pages 7 and 8 if there are 10 total pages)   * Stride (::w) : Keep 1 page every w pages starting at the first one (example ::2 will keep only odd pages)   * Range and stride (x:y:w) : Keep 1 page every w pages within range (x:y) (example 1::2 will keep only even pages)  You can use multiple ranges of page at once, comma separated (For example, 0,2:5,-2:-1 keeps the 1st page, plus pages 3->5, plus the second to last page) 
        :type page_range: str
        :param callback_url: Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.
        :type callback_url: str
        :param save_result: If you want to save the result as a json document
        :type save_result: bool
        :param model_params: Additional parameters that will be passed as is to the model.
        :type model_params: object
        :param block_processing: If true, blocks processing on the job until /job/{id}/start is called. Default is false
        :type block_processing: bool
        :param apply_body: All the previous query parameters can also be passed as JSON in the body of the request
        :type apply_body: ApplyBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Job, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'token',
            'model_id',
            'document_ids',
            'tag',
            'format_type',
            'execute_after_id',
            'page_range',
            'callback_url',
            'save_result',
            'model_params',
            'block_processing',
            'apply_body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method apply_model_async" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['model_id']:
            _path_params['model_id'] = _params['model_id']
        if _params['document_ids']:
            _path_params['document_ids'] = _params['document_ids']
            _collection_formats['document_ids'] = 'csv'

        # process the query parameters
        _query_params = []
        if _params.get('tag') is not None:  # noqa: E501
            _query_params.append(('tag', _params['tag']))
        if _params.get('format_type') is not None:  # noqa: E501
            _query_params.append(('format_type', _params['format_type']))
        if _params.get('execute_after_id') is not None:  # noqa: E501
            _query_params.append(('execute_after_id', _params['execute_after_id']))
        if _params.get('page_range') is not None:  # noqa: E501
            _query_params.append(('page_range', _params['page_range']))
        if _params.get('callback_url') is not None:  # noqa: E501
            _query_params.append(('callback_url', _params['callback_url']))
        if _params.get('save_result') is not None:  # noqa: E501
            _query_params.append(('save_result', _params['save_result']))
        if _params.get('model_params') is not None:  # noqa: E501
            _query_params.append(('model_params', _params['model_params']))
        if _params.get('block_processing') is not None:  # noqa: E501
            _query_params.append(('block_processing', _params['block_processing']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['token']:
            _header_params['token'] = _params['token']

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params['apply_body']:
            _body_params = _params['apply_body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Job",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/model/{model_id}/apply/{document_ids}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_model(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], model_id : Annotated[StrictStr, Field(..., description="The id or the short name of the model to get")], **kwargs) -> Model:  # noqa: E501
        """Get a model  # noqa: E501

        Get a model in the system that the application can access  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_model(token, model_id, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param model_id: The id or the short name of the model to get (required)
        :type model_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Model
        """
        kwargs['_return_http_data_only'] = True
        return self.get_model_with_http_info(token, model_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_model_with_http_info(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], model_id : Annotated[StrictStr, Field(..., description="The id or the short name of the model to get")], **kwargs):  # noqa: E501
        """Get a model  # noqa: E501

        Get a model in the system that the application can access  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_model_with_http_info(token, model_id, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param model_id: The id or the short name of the model to get (required)
        :type model_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Model, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'token',
            'model_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['model_id']:
            _path_params['model_id'] = _params['model_id']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['token']:
            _header_params['token'] = _params['token']

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Model",
            '401': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/model/{model_id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_models(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], model_id : Annotated[Optional[StrictStr], Field(description="Filter by id")] = None, model_type : Annotated[Optional[ModelTypes], Field(description="Filter by type")] = None, name : Annotated[Optional[StrictStr], Field(description="Filter by name")] = None, short_name : Annotated[Optional[StrictStr], Field(description="Filter by short name")] = None, description : Annotated[Optional[StrictStr], Field(description="Gets models that contain this string in their description")] = None, input_types : Annotated[Optional[List[ModelInputTypes]], Field(description="Filter by input type")] = None, tags : Annotated[Optional[List[StrictStr]], Field(description="If specified, filters the models by tag")] = None, created_after : Annotated[Optional[datetime], Field(description="If specified, keeps only models created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)")] = None, created_before : Annotated[Optional[datetime], Field(description="If specified, keeps only models created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)")] = None, only_mine : Annotated[Optional[StrictBool], Field(description="If true, will list only models that strictly belong to logged in application (and not all the models that it can use) (false by default)")] = None, sort : Annotated[Optional[StrictStr], Field(description="If specified, sorts the models by a list of existing parameters separated by commas. Can be 'application_id', 'creation_time', 'name', 'description', 'model_type'. Sorts in ascending order by default. If a parameter is preceded by '-', it is sorted in descending order.")] = None, offset : Annotated[Optional[StrictInt], Field(description="Number of the first model to send (pagination)")] = None, limit : Annotated[Optional[StrictInt], Field(description="Maximum number of models to send (pagination)")] = None, **kwargs) -> List[Model]:  # noqa: E501
        """Lists models (paginated)  # noqa: E501

        Lists models corresponding to the filters that the application can access  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_models(token, model_id, model_type, name, short_name, description, input_types, tags, created_after, created_before, only_mine, sort, offset, limit, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param model_id: Filter by id
        :type model_id: str
        :param model_type: Filter by type
        :type model_type: ModelTypes
        :param name: Filter by name
        :type name: str
        :param short_name: Filter by short name
        :type short_name: str
        :param description: Gets models that contain this string in their description
        :type description: str
        :param input_types: Filter by input type
        :type input_types: List[ModelInputTypes]
        :param tags: If specified, filters the models by tag
        :type tags: List[str]
        :param created_after: If specified, keeps only models created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :type created_after: datetime
        :param created_before: If specified, keeps only models created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :type created_before: datetime
        :param only_mine: If true, will list only models that strictly belong to logged in application (and not all the models that it can use) (false by default)
        :type only_mine: bool
        :param sort: If specified, sorts the models by a list of existing parameters separated by commas. Can be 'application_id', 'creation_time', 'name', 'description', 'model_type'. Sorts in ascending order by default. If a parameter is preceded by '-', it is sorted in descending order.
        :type sort: str
        :param offset: Number of the first model to send (pagination)
        :type offset: int
        :param limit: Maximum number of models to send (pagination)
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Model]
        """
        kwargs['_return_http_data_only'] = True
        return self.get_models_with_http_info(token, model_id, model_type, name, short_name, description, input_types, tags, created_after, created_before, only_mine, sort, offset, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def get_models_with_http_info(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], model_id : Annotated[Optional[StrictStr], Field(description="Filter by id")] = None, model_type : Annotated[Optional[ModelTypes], Field(description="Filter by type")] = None, name : Annotated[Optional[StrictStr], Field(description="Filter by name")] = None, short_name : Annotated[Optional[StrictStr], Field(description="Filter by short name")] = None, description : Annotated[Optional[StrictStr], Field(description="Gets models that contain this string in their description")] = None, input_types : Annotated[Optional[List[ModelInputTypes]], Field(description="Filter by input type")] = None, tags : Annotated[Optional[List[StrictStr]], Field(description="If specified, filters the models by tag")] = None, created_after : Annotated[Optional[datetime], Field(description="If specified, keeps only models created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)")] = None, created_before : Annotated[Optional[datetime], Field(description="If specified, keeps only models created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)")] = None, only_mine : Annotated[Optional[StrictBool], Field(description="If true, will list only models that strictly belong to logged in application (and not all the models that it can use) (false by default)")] = None, sort : Annotated[Optional[StrictStr], Field(description="If specified, sorts the models by a list of existing parameters separated by commas. Can be 'application_id', 'creation_time', 'name', 'description', 'model_type'. Sorts in ascending order by default. If a parameter is preceded by '-', it is sorted in descending order.")] = None, offset : Annotated[Optional[StrictInt], Field(description="Number of the first model to send (pagination)")] = None, limit : Annotated[Optional[StrictInt], Field(description="Maximum number of models to send (pagination)")] = None, **kwargs):  # noqa: E501
        """Lists models (paginated)  # noqa: E501

        Lists models corresponding to the filters that the application can access  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_models_with_http_info(token, model_id, model_type, name, short_name, description, input_types, tags, created_after, created_before, only_mine, sort, offset, limit, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param model_id: Filter by id
        :type model_id: str
        :param model_type: Filter by type
        :type model_type: ModelTypes
        :param name: Filter by name
        :type name: str
        :param short_name: Filter by short name
        :type short_name: str
        :param description: Gets models that contain this string in their description
        :type description: str
        :param input_types: Filter by input type
        :type input_types: List[ModelInputTypes]
        :param tags: If specified, filters the models by tag
        :type tags: List[str]
        :param created_after: If specified, keeps only models created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :type created_after: datetime
        :param created_before: If specified, keeps only models created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :type created_before: datetime
        :param only_mine: If true, will list only models that strictly belong to logged in application (and not all the models that it can use) (false by default)
        :type only_mine: bool
        :param sort: If specified, sorts the models by a list of existing parameters separated by commas. Can be 'application_id', 'creation_time', 'name', 'description', 'model_type'. Sorts in ascending order by default. If a parameter is preceded by '-', it is sorted in descending order.
        :type sort: str
        :param offset: Number of the first model to send (pagination)
        :type offset: int
        :param limit: Maximum number of models to send (pagination)
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Model], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'token',
            'model_id',
            'model_type',
            'name',
            'short_name',
            'description',
            'input_types',
            'tags',
            'created_after',
            'created_before',
            'only_mine',
            'sort',
            'offset',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_models" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('model_id') is not None:  # noqa: E501
            _query_params.append(('model_id', _params['model_id']))
        if _params.get('model_type') is not None:  # noqa: E501
            _query_params.append(('model_type', _params['model_type']))
        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))
        if _params.get('short_name') is not None:  # noqa: E501
            _query_params.append(('short_name', _params['short_name']))
        if _params.get('description') is not None:  # noqa: E501
            _query_params.append(('description', _params['description']))
        if _params.get('input_types') is not None:  # noqa: E501
            _query_params.append(('input_types', _params['input_types']))
            _collection_formats['input_types'] = 'multi'
        if _params.get('tags') is not None:  # noqa: E501
            _query_params.append(('tags', _params['tags']))
            _collection_formats['tags'] = 'multi'
        if _params.get('created_after') is not None:  # noqa: E501
            _query_params.append(('created_after', _params['created_after']))
        if _params.get('created_before') is not None:  # noqa: E501
            _query_params.append(('created_before', _params['created_before']))
        if _params.get('only_mine') is not None:  # noqa: E501
            _query_params.append(('only_mine', _params['only_mine']))
        if _params.get('sort') is not None:  # noqa: E501
            _query_params.append(('sort', _params['sort']))
        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))
        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['token']:
            _header_params['token'] = _params['token']

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[Model]",
            '401': None,
        }

        return self.api_client.call_api(
            '/model', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def tag_model(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], model_id : Annotated[StrictStr, Field(..., description="The id of the model")], tag : Annotated[StrictStr, Field(..., description="The tag to add to the model")], **kwargs) -> Model:  # noqa: E501
        """Tags a model  # noqa: E501

        Tags a model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tag_model(token, model_id, tag, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param model_id: The id of the model (required)
        :type model_id: str
        :param tag: The tag to add to the model (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Model
        """
        kwargs['_return_http_data_only'] = True
        return self.tag_model_with_http_info(token, model_id, tag, **kwargs)  # noqa: E501

    @validate_arguments
    def tag_model_with_http_info(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], model_id : Annotated[StrictStr, Field(..., description="The id of the model")], tag : Annotated[StrictStr, Field(..., description="The tag to add to the model")], **kwargs):  # noqa: E501
        """Tags a model  # noqa: E501

        Tags a model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tag_model_with_http_info(token, model_id, tag, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param model_id: The id of the model (required)
        :type model_id: str
        :param tag: The tag to add to the model (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Model, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'token',
            'model_id',
            'tag'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tag_model" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['model_id']:
            _path_params['model_id'] = _params['model_id']
        if _params['tag']:
            _path_params['tag'] = _params['tag']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['token']:
            _header_params['token'] = _params['token']

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Model",
            '401': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/model/{model_id}/tag/{tag}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def train_model_async(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], model_module : Annotated[StrictStr, Field(..., description="The module name of the model to train on documents")], documents_tag : Annotated[StrictStr, Field(..., description="The tag of the documents to train with")], model_name : Annotated[Optional[StrictStr], Field(description="The future name of the model in database")] = None, short_name : Annotated[Optional[StrictStr], Field(description="The new short name of the model")] = None, description : Annotated[Optional[StrictStr], Field(description="The description of the model")] = None, ttl : Annotated[Optional[StrictInt], Field(description="The TTL of the model in seconds, if running in worker mode (negative for infinite TTL, default is 200)")] = None, allowed_application_ids : Annotated[Optional[List[StrictStr]], Field(description="The applications allowed to use this model")] = None, allow_all_applications : Annotated[Optional[StrictBool], Field(description="Is this model allowed for everyone ?")] = None, tags : Annotated[Optional[List[StrictStr]], Field(description="The tags of the model")] = None, execute_after_id : Annotated[Optional[StrictStr], Field(description="The job that is a prerequisite for this job to run")] = None, callback_url : Annotated[Optional[StrictStr], Field(description="Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.")] = None, model_params : Annotated[Optional[Dict[str, StrictStr]], Field(description="Additional parameters that will be passed as is to the train method")] = None, train_body : Annotated[Optional[TrainBody], Field(description="All the previous query parameters can also be passed as JSON in the body of the request")] = None, **kwargs) -> Job:  # noqa: E501
        """Asynchronously trains a model on documents (admin only)  # noqa: E501

        Asynchronously trains a model on accessible documents and returns a Job, that will have to be polled to get the result. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.train_model_async(token, model_module, documents_tag, model_name, short_name, description, ttl, allowed_application_ids, allow_all_applications, tags, execute_after_id, callback_url, model_params, train_body, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param model_module: The module name of the model to train on documents (required)
        :type model_module: str
        :param documents_tag: The tag of the documents to train with (required)
        :type documents_tag: str
        :param model_name: The future name of the model in database
        :type model_name: str
        :param short_name: The new short name of the model
        :type short_name: str
        :param description: The description of the model
        :type description: str
        :param ttl: The TTL of the model in seconds, if running in worker mode (negative for infinite TTL, default is 200)
        :type ttl: int
        :param allowed_application_ids: The applications allowed to use this model
        :type allowed_application_ids: List[str]
        :param allow_all_applications: Is this model allowed for everyone ?
        :type allow_all_applications: bool
        :param tags: The tags of the model
        :type tags: List[str]
        :param execute_after_id: The job that is a prerequisite for this job to run
        :type execute_after_id: str
        :param callback_url: Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.
        :type callback_url: str
        :param model_params: Additional parameters that will be passed as is to the train method
        :type model_params: object
        :param train_body: All the previous query parameters can also be passed as JSON in the body of the request
        :type train_body: TrainBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Job
        """
        kwargs['_return_http_data_only'] = True
        return self.train_model_async_with_http_info(token, model_module, documents_tag, model_name, short_name, description, ttl, allowed_application_ids, allow_all_applications, tags, execute_after_id, callback_url, model_params, train_body, **kwargs)  # noqa: E501

    @validate_arguments
    def train_model_async_with_http_info(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], model_module : Annotated[StrictStr, Field(..., description="The module name of the model to train on documents")], documents_tag : Annotated[StrictStr, Field(..., description="The tag of the documents to train with")], model_name : Annotated[Optional[StrictStr], Field(description="The future name of the model in database")] = None, short_name : Annotated[Optional[StrictStr], Field(description="The new short name of the model")] = None, description : Annotated[Optional[StrictStr], Field(description="The description of the model")] = None, ttl : Annotated[Optional[StrictInt], Field(description="The TTL of the model in seconds, if running in worker mode (negative for infinite TTL, default is 200)")] = None, allowed_application_ids : Annotated[Optional[List[StrictStr]], Field(description="The applications allowed to use this model")] = None, allow_all_applications : Annotated[Optional[StrictBool], Field(description="Is this model allowed for everyone ?")] = None, tags : Annotated[Optional[List[StrictStr]], Field(description="The tags of the model")] = None, execute_after_id : Annotated[Optional[StrictStr], Field(description="The job that is a prerequisite for this job to run")] = None, callback_url : Annotated[Optional[StrictStr], Field(description="Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.")] = None, model_params : Annotated[Optional[Dict[str, StrictStr]], Field(description="Additional parameters that will be passed as is to the train method")] = None, train_body : Annotated[Optional[TrainBody], Field(description="All the previous query parameters can also be passed as JSON in the body of the request")] = None, **kwargs):  # noqa: E501
        """Asynchronously trains a model on documents (admin only)  # noqa: E501

        Asynchronously trains a model on accessible documents and returns a Job, that will have to be polled to get the result. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.train_model_async_with_http_info(token, model_module, documents_tag, model_name, short_name, description, ttl, allowed_application_ids, allow_all_applications, tags, execute_after_id, callback_url, model_params, train_body, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param model_module: The module name of the model to train on documents (required)
        :type model_module: str
        :param documents_tag: The tag of the documents to train with (required)
        :type documents_tag: str
        :param model_name: The future name of the model in database
        :type model_name: str
        :param short_name: The new short name of the model
        :type short_name: str
        :param description: The description of the model
        :type description: str
        :param ttl: The TTL of the model in seconds, if running in worker mode (negative for infinite TTL, default is 200)
        :type ttl: int
        :param allowed_application_ids: The applications allowed to use this model
        :type allowed_application_ids: List[str]
        :param allow_all_applications: Is this model allowed for everyone ?
        :type allow_all_applications: bool
        :param tags: The tags of the model
        :type tags: List[str]
        :param execute_after_id: The job that is a prerequisite for this job to run
        :type execute_after_id: str
        :param callback_url: Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.
        :type callback_url: str
        :param model_params: Additional parameters that will be passed as is to the train method
        :type model_params: object
        :param train_body: All the previous query parameters can also be passed as JSON in the body of the request
        :type train_body: TrainBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Job, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'token',
            'model_module',
            'documents_tag',
            'model_name',
            'short_name',
            'description',
            'ttl',
            'allowed_application_ids',
            'allow_all_applications',
            'tags',
            'execute_after_id',
            'callback_url',
            'model_params',
            'train_body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method train_model_async" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['model_module']:
            _path_params['model_module'] = _params['model_module']
        if _params['documents_tag']:
            _path_params['documents_tag'] = _params['documents_tag']

        # process the query parameters
        _query_params = []
        if _params.get('model_name') is not None:  # noqa: E501
            _query_params.append(('model_name', _params['model_name']))
        if _params.get('short_name') is not None:  # noqa: E501
            _query_params.append(('short_name', _params['short_name']))
        if _params.get('description') is not None:  # noqa: E501
            _query_params.append(('description', _params['description']))
        if _params.get('ttl') is not None:  # noqa: E501
            _query_params.append(('ttl', _params['ttl']))
        if _params.get('allowed_application_ids') is not None:  # noqa: E501
            _query_params.append(('allowed_application_ids', _params['allowed_application_ids']))
            _collection_formats['allowed_application_ids'] = 'multi'
        if _params.get('allow_all_applications') is not None:  # noqa: E501
            _query_params.append(('allow_all_applications', _params['allow_all_applications']))
        if _params.get('tags') is not None:  # noqa: E501
            _query_params.append(('tags', _params['tags']))
            _collection_formats['tags'] = 'multi'
        if _params.get('execute_after_id') is not None:  # noqa: E501
            _query_params.append(('execute_after_id', _params['execute_after_id']))
        if _params.get('callback_url') is not None:  # noqa: E501
            _query_params.append(('callback_url', _params['callback_url']))
        if _params.get('model_params') is not None:  # noqa: E501
            _query_params.append(('model_params', _params['model_params']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['token']:
            _header_params['token'] = _params['token']

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params['train_body']:
            _body_params = _params['train_body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Job",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/model/{model_module}/train/{documents_tag}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def untag_model(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], model_id : Annotated[StrictStr, Field(..., description="The id of the model")], tag : Annotated[StrictStr, Field(..., description="The tag to delete from the model")], **kwargs) -> None:  # noqa: E501
        """Untags a model  # noqa: E501

        Untags a model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.untag_model(token, model_id, tag, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param model_id: The id of the model (required)
        :type model_id: str
        :param tag: The tag to delete from the model (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.untag_model_with_http_info(token, model_id, tag, **kwargs)  # noqa: E501

    @validate_arguments
    def untag_model_with_http_info(self, token : Annotated[StrictStr, Field(..., description="The login token obtained via POST /login/")], model_id : Annotated[StrictStr, Field(..., description="The id of the model")], tag : Annotated[StrictStr, Field(..., description="The tag to delete from the model")], **kwargs):  # noqa: E501
        """Untags a model  # noqa: E501

        Untags a model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.untag_model_with_http_info(token, model_id, tag, async_req=True)
        >>> result = thread.get()

        :param token: The login token obtained via POST /login/ (required)
        :type token: str
        :param model_id: The id of the model (required)
        :type model_id: str
        :param tag: The tag to delete from the model (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'token',
            'model_id',
            'tag'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method untag_model" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['model_id']:
            _path_params['model_id'] = _params['model_id']
        if _params['tag']:
            _path_params['tag'] = _params['tag']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['token']:
            _header_params['token'] = _params['token']

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/model/{model_id}/tag/{tag}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
