# flake8: noqa: W503
import os
import re
import subprocess
from typing import Dict, Any, AnyStr, List
from io import TextIOWrapper
from caseconverter.camel import camelcase
from ..utils import wait_for_processes
from .generator import JTDCodeGenerator


class JTDCodeGeneratorPythonTarget(JTDCodeGenerator):
    """Generate code from the JSON Type Definition files for Python.

    It does a normal code generation which is done by :class:`JTDCodeGenerator`_,
    and in addition it substitutes python built-in dataclass decorator
    to pydantic's dataclass decorator if `use-pydantic` is set to true.
    """

    class_regex = r"^class ([a-zA-Z0-9_]+)[(]{0,1}(.*)[)]{0,1}:$"
    """This regex captures the class name from the class definition line.

    It captures 2 groups:
        1. The class name
        2. The arguments passed to the class

    For example, if the class definition line is `class DummyClass:`,
    it captures `DummyClass` as the class name.

    If the class definition line is `class DummyClass(SomeClass):`,
    it captures `DummyClass` as the class name and `SomeClass` as the argument.
    """

    type_hint_regex = r"^[ ]{4}[a-zA-Z0-9_]+:[ ]{1}'[a-zA-Z0-9\[\],_\'\" ]+'$"
    """This regex captures the type hint line.
    
    For example, if the type hint line is `    a: 'Dict[str, Any]'`,
    regex captures this line.
    """

    classmethod_regex = r"^[ ]{4}@classmethod$"
    """This regex captures the classmethod decorator line.
    """

    subscript_methods = [
        "    def __getitem__(self, key: str) -> Any:\n",
        "        return getattr(self, key)\n",
        "\n",
        "    def __setitem__(self, key: str, value: Any) -> None:\n",
        "        setattr(self, key, value)\n",
        "\n",
        "    def get(self, key: str, default: Any = None) -> None:\n",
        "        return getattr(self, key, default)\n",
        "\n",
    ]
    """These lines are injected to the generated code to make the dataclass
    subscriptable.
    """

    def _open_schema_file(
        self,
        target_path: str,
        mode: str,
    ) -> TextIOWrapper:
        """Open the schema file.

        Args:
            target_path: The target path.

        Returns:
            The opened schema file.
        """
        schema_file_path = os.path.join(target_path, "__init__.py")
        return open(schema_file_path, mode)

    def _remove_jtd_codegen_generated_methods(
        self,
        lines: List[AnyStr],
    ) -> List[AnyStr]:
        """Remove the methods generated by jtd-codegen.

        Args:
            lines: The lines to remove.

        Returns:
            Remaining lines.
        """
        # Find the line where the `dataclass` decorator is called
        start_indexes = [
            i
            for i, line in enumerate(lines)
            if re.match(self.classmethod_regex, line) is not None
        ]
        # Remove first line as we'll not consider that in `Schema` class
        start_indexes.pop(0)

        # Find the line where `return data` line is called
        end_indexes = [
            i
            for i, line in enumerate(lines)
            if re.match(r"^[ ]{8}return data$", line) is not None
        ]

        # Fill every lines between `start_index` and `end_index` pair with None
        for start_index, end_index in zip(start_indexes, end_indexes):
            lines[start_index : end_index + 1] = [None] * (end_index + 1 - start_index)

        # Remove all `None` lines
        lines = list(filter(lambda x: x is not None, lines))

        return lines

    def _substitute_types_to_impls(
        self,
        lines: List[AnyStr],
    ) -> List[AnyStr]:
        """Substitute types to implementations.
        For example, `Dict`, to `dict`, `Any` to `object`, etc.

        Args:
            lines: The lines to substitute.

        Returns:
            The substituted lines.
        """
        for i, line in enumerate(lines):
            # If the line is a type hint, substitute it to an implementation.
            if re.match(self.type_hint_regex, line) is not None:
                lines[i] = (
                    line.replace("Dict", "dict")
                    .replace("Any", "object")
                    .replace("List", "list")
                )

        return lines

    def _append_none_to_optional_fields(
        self,
        lines: List[AnyStr],
    ) -> List[AnyStr]:
        """Append `None` to the optional fields.

        Args:
            lines: The lines to append.

        Returns:
            The appended lines.
        """
        for i, line in enumerate(lines):
            # If the line is a type hint and the type starts with `Optional`,
            # append `None` to the type.
            if (
                re.match(self.type_hint_regex, line) is not None
                and "'Optional[" in line
            ):
                code, _ = line.split("\n")
                lines[i] = f"{code} = None\n"

        return lines

    def _inject_rebuild_dataclass_calls(
        self,
        lines: List[AnyStr],
    ) -> List[AnyStr]:
        """Injects `rebuild_dataclass`_ calls to the code.

        Args:
            lines: The lines to inject.

        Returns:
            The injected lines.
        """
        rebuild_model_calls: List[str] = [
            "\n",
            "# Rebuild models\n",
            "\n",
        ]

        # Find the line where the `dataclass` decorator is called
        for line in lines:
            # Extract the class name if the line is a class definition
            regex_match: re.Match = re.match(self.class_regex, line)
            if regex_match is None:
                continue
            class_name = regex_match.group(1)

            # Inject `rebuild_dataclass` call
            rebuild_model_calls.append(f"rebuild_dataclass({class_name})\n")

        # Append the `rebuild_dataclass` calls to the end of the file
        lines.extend(rebuild_model_calls)

        return lines

    def _with_camel_cased_property_names(self, lines: List[AnyStr]) -> List[AnyStr]:
        """Converts the property names to camel case.

        Args:
            lines: The lines to convert.

        Returns:
            The converted lines.
        """
        for i, line in enumerate(lines):
            # If the line is a type hint, convert the property name to camel case.
            if re.match(self.type_hint_regex, line) is not None:
                property_name = line.split(":")[0].strip()
                lines[i] = line.replace(property_name, camelcase(property_name))

        return lines

    def _with_pydantic(self, lines: List[AnyStr]) -> List[AnyStr]:
        # Inject pydantic's dataclass decorator to the generated code
        # if `use-pydantic` is set to true.

        # Remove built-in dataclass decorator imoprt
        lines.remove("from dataclasses import dataclass\n")

        # Import pydantic's dataclass decorator
        # and related functions
        lines.insert(2, "import dataclasses\n")
        lines.insert(
            3,
            "from pydantic.dataclasses import dataclass, rebuild_dataclass\n",
        )

        # Substitute `typing` package types to actual implementations
        lines = self._substitute_types_to_impls(lines)

        # Append `None` to the optional fields
        lines = self._append_none_to_optional_fields(lines)

        # Inject :meth:`.model_rebuild`_ calls for every models
        lines = self._inject_rebuild_dataclass_calls(lines)

        return lines

    def _with_typeddict(self, lines: List[AnyStr]) -> List[AnyStr]:
        # Inject typeddict's dataclass decorator to the generated code
        # if `use-typeddict` is set to true.

        # Remove built-in dataclass decorator imoprt
        lines.remove("from dataclasses import dataclass\n")

        # Import `TypedDict` from `typing` package
        lines.insert(2, "from typing import TypedDict\n")

        # Remove all `@dataclass` decorators
        for i, line in enumerate(lines):
            if re.match(r"@dataclass", line) is not None:
                lines[i] = ""

        # Inherit every classes from `TypedDict`
        for i, line in enumerate(lines):
            match: re.Match = re.match(self.class_regex, line)
            if match is not None and match.group(1) != "Schema":
                lines[i] = f"class {match.group(1)}(TypedDict):\n"

        # Remove all `from_json_data` and `to_json_data` methods
        lines = self._remove_jtd_codegen_generated_methods(lines)

        return lines

    def _with_subscriptable_dataclass(self, lines: List[AnyStr]) -> List[AnyStr]:
        # We insert the subscriptable methods to the line before the classmethod
        # decorator line.
        line_indexes_to_insert = [
            i
            for i, line in enumerate(lines)
            if re.match(self.classmethod_regex, line) is not None
        ]

        # Insert the subscriptable methods code lines
        lines_methods_inserted: List[AnyStr] = []
        for i, line in enumerate(lines):
            if i in line_indexes_to_insert:
                lines_methods_inserted.extend(self.subscript_methods)
            lines_methods_inserted.append(line)

        return lines_methods_inserted

    def _validate_options(self, target: Dict[AnyStr, Any]) -> None:
        """Validate the options.

        Args:
            target: The target to validate.

        Raises:
            ValueError: If the options are invalid.
        """
        if target["language"] != "python":
            raise ValueError("Target language must be python")

        use_pydanitc = target.get("use-pydantic", False)
        use_typeddict = target.get("use-typeddict", False)
        property_case = target.get("property-case", None)
        subscriptable = target.get("subscriptable", None)

        if use_pydanitc and use_typeddict:
            raise ValueError("Cannot use both typeddict and pydantic")

        if use_typeddict and subscriptable is not None:
            raise Warning(
                "TypedDict is always subscriptable. `subscriptable` option is ignored."
            )
        if property_case is not None and use_typeddict is False:
            raise Warning(
                "`propery-case` option is currently only supported for typeddict."
                "The option is ignored."
            )

    def generate(self, target: Dict[AnyStr, Any]) -> List[subprocess.Popen]:
        """Generate code from the JSON Type Definition files for Python.

        It does a normal code generation which is done by :class:`JTDCodeGenerator`_,
        and in addition it substitutes python built-in dataclass decorator
        to pydantic's dataclass decorator if `use-pydantic` is set to true,
        or use typeddict if `use-typeddict` is set to true.

        Args:
            target: The target to generate code.

        Returns:
            The list of processes.
        """
        self._validate_options(target)

        processes = super().generate(target)

        # Wait for existing processes to finish before starting the modification
        # process.
        wait_for_processes(processes, print_stdout=False)

        # Read the generated code
        target_path = self.get_target_path(target)
        with self._open_schema_file(target_path, "r") as f:
            lines = f.readlines()

        # Disable linter for the entire file
        lines.insert(0, "# flake8: noqa\n")

        use_pydanitc = target.get("use-pydantic", False)
        use_typeddict = target.get("use-typeddict", False)
        property_case = target.get("property-case", "snake")
        subscriptable = target.get("subscriptable", False)

        if use_pydanitc:
            lines = self._with_pydantic(lines)

        if use_typeddict:
            lines = self._with_typeddict(lines)

        if property_case == "camel" and use_typeddict:
            lines = self._with_camel_cased_property_names(lines)

        if subscriptable and not use_typeddict:
            lines = self._with_subscriptable_dataclass(lines)

        # Write the modified code to the file
        with self._open_schema_file(target_path, "w") as f:
            f.writelines(lines)

        return processes
