This document is a place to discuss design decisions that support this Python NetDot API wrapper.

> ⚠ Disclaimer: From 0.2.0 onward, this API wrapper may not support the [de facto Open Source version of NetDot (GitHub)](https://github.com/cvicente/Netdot).
>
> From 0.2.0 onward, this API wrapper has been built to support [UO's NetDot implementation (access restricted)](https://nsdb.uoregon.edu).

# API Wrapper Layers

We consider this API wrapper to have a layered design, portrayed in the table below.

| Layer | Title       | Description                                                                  |
| ----- | ----------- | ---------------------------------------------------------------------------- |
| 3     | UnitOfWork  | Plan some work with well-typed NetDot [Data classes](#data-classes-netdotdataclasses). |
| 2     | Repository  | Work with well-typed NetDot [Data classes](#data-classes-netdotdataclasses). |
| 1     | Client      | Work with Python dictionaries.                                               |
| 0     | RESTful API | Work directly with the XML bytes provided by HTTP.                           |

These are software layers, which implies dependencies between layers occur only in the following ways:

* Client: depends on RESTful API.
* *Repository: depends on the Client.
* UnitOfWork: depends on Repository.

> *: In reality, we've actually integrated the UnitOfWork into the Repository as the 'DRY RUN' feature.
> So, Repository depends on UnitOfWork, even though according to these layers, it should not.

# Repository and Data Classes

The primary interface of this API wrapper is the `Repository` class.
That Repository will operate based on well-typed Data classes -- implemented using [Python `dataclasses`](https://docs.python.org/3/library/dataclasses.html)

## Repository class: `netdot.Repository`

Being the primary interface of this API wrapper, we have the following goals for our `Repository` class:

* use **consistent naming** for methods, and
* provide complete and accurate **docstrings** for every method.


## Data Classes: `netdot.dataclasses`

The `netdot.dataclasses` package contains all the Python dataclasses that represent NetDot objects.
These dataclasses are roughly based on the [UO NSDB NetDot's Relationships (access restricted)](https://is-nsdb.uoregon.edu/help/database-rels.html).

### Data Class Conventions

These are the conventions we use to try and make this library most useful to the most people.

* Follow PEP 8 for class naming.
* These are mutable dataclasses.
* All data classes are subclasses of the `NetdotAPIDataclass` base class.
* These classes have fields with names matching what is returned from the RESTful API.
  *  `_xlink` suffix if they are related to another Data class.

# Generated code

We realized when implementing our various naming conventions that the code had become very generic.
In fact, we were copy-pasting a LOT of code between Data classes and Repository methods.
As a result, some methods and field names had typos -- it was transforming into a monstrous code base!

So, rather than spending time copy-pasting all the code, we decided to implement all the generic logic we could in 'generate functions.'

> ℹ Using a generated code solution automatically ensures that our code follow conventions *perfectly, every time, (without any typos)*.

## Repository 'generate functions'

Most of the Repository's `get_*` functions are generated by the '`generate_...`' functions in the `netdot.repository` module.

> ✅ In addition to enforcing method naming conventions, the '`generate_...`' functions will also *generate the docstrings for every method*!

### `netdot.dataclass` 'generate functions'

TODO


# Client

The Client is a simple API wrapper that enables working with [NetDot's RESTful API](api.md), but as Python dictionaries.

From the high level perspective, this layer converts 'NetDot XML data' into 'Python dictionaries' (for HTTP GET requests).
Additionally, this layer converts from dictionaries to 'NetDot XML data' (for HTTP POST requests)!

> ℹ The Client is implemented using a [`requests` HTTP Sesssion (`requests` docs)](https://requests.readthedocs.io/en/latest/user/advanced/#session-objects).

> TODO: Discuss Client_v1 history... or cleanup Client_v1 entirely...

# Appendix: Create a Subclass of NetdotAPIDataclass

To support maximum interoperability, it is best if all our dataclasses extend from NetdotAPIDataclass.

## `NetdotAPIDataclass` Subclass Boiler Plate

Here is the boilerplate code you'd start to define the `Device` dataclass in "dataclasses/device.py". 

    from dataclasses import dataclass
    from netdot.csv_util import CSVDataclass
    from netdot.dataclasses.base import NetdotAPIDataclass

    @dataclass
    class DHCPScope(NetdotAPIDataclass, CSVDataclass):
        _NETDOT_TABLE_NAME = 'DhcpScope'  # ⨥: Appropriate capitalization pulled from Netdot

> ⨥: Appropriate capitalization can be inferred by loading NetDot then looking at "Advanced -> Browse Tables".


## Initialize the Subclass

Additionally, ensure that the `dataclasses/__init__.py` file properly initializes and exposes your dataclass.

> ℹ This is a requirement for the [generated code solution](#generated-code) auto-wiring to succeed. 

    # 1. Import the class
    from .device import Device

    def initialize():
        if not _initialized:
            # 2. Initialize the class (required by internal generated-code solution) 
            Device()

    __all__ = [
        # 3. Expose the class throughout this module
        'Device', 
    ]

## Expose the Subclass

To make sure that the class appears at the top level of the `netdot` module, add it to the `__all__` list in "`src/netdot/__init__.py`" as well.

## Test the Subclass

There are some basic tests that can be written for any of these auto-wired dataclasses.
These test cases are written in the "test_repository.py"

> ℹ Tip: When using VSCode to run tests, the *"Python Test Log"* output can be found in the *Output Pane (Ctrl + Shift + U)*.
> 
> **⚠ Warning**: It is important to check this output when testing to see if any  `WARNING`s are emitted by the newly generated code!

- [ ] `repository.get_X()`: Get some arbitrary item by its ID.
- [ ] Review the "`test_Repository_initialization_of_methods`" test case -- consider adding assert statements for any methods you expect to be populated in the `netdot.Repository` class.

